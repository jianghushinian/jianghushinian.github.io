---
title: Python 可变类型作为函数默认参数时的副作用
date: 2019-09-15 09:55:32
tags:
- Python
categories:
- Python
---

在 Python 中定义函数时，可以为其指定 `默认参数`，这样就不必在每次调用函数时都传递参数进去，并且可以简化我们的代码。

<!-- more -->

在定义函数时，如果使用了 `可变类型` 来作为函数的 `默认参数`，往往会产生一些副作用。来看下面一段代码。

```python
def foo(li=[]):
    li.append(1)
    print(li)

foo()
foo()
foo()
```

你可能想得到如下的结果：

```
[1]
[1]
[1]
```

但实际上，结果却是：

```
[1]
[1, 1]
[1, 1, 1]
```

根据结果来看，似乎每次的函数调用，`li` 列表都记录了上一次的调用结果，而并没有使用默认参数 `[]`。但是当我们在每次调用函数时，都传递一个空列表 `[]` 进去，就不会出现副作用，能够正确得到我们想要的结果。

```python
def foo(li=[]):
    li.append(1)
    print(li)

foo([])
foo([])
foo([])
```

```
[1]
[1]
[1]
```

为什么会产生这样的结果呢？其实这个问题的原因是 Python 中函数的特性所决定的。由于函数也是 `对象`，而 `对象` 可以有自己的属性，所以函数也有自己的属性。

当 `foo` 函数被创建时，它的 `默认参数` 就已经被保存在它的 `__defaults__` 属性中了。而函数只会被创建一次，以后每次执行 `foo()` 的时候，都只会调用函数，并不会去重新创建一个函数。所以函数的 `默认参数` 也只会计算一次，无论之后被调用多少次，`默认参数` 始终都是同一个 `对象`。

我们用 `id()` 函数打印出默认参数的内存地址就能够看出来。

```python
def foo(li=[]):
    li.append(1)
    print(li, id(li))

foo()
foo()
foo()
```

```
[1] 48904632
[1, 1] 48904632
[1, 1, 1] 48904632
```

可以看出，三次调用函数后，其内部打印的 `li` 地址是相同的，所以它们其实是同一个 `对象`。

知道了问题的原因，那么如果解决它呢？我们可以用 `None` 来作为函数的 `默认参数`，在调用 `foo` 函数时，在函数体内部可以通过判断 `li` 是否为 `None` 来决定是否需要使用 `默认值`。这样，当调用 `foo()` 函数并且没有传递参数时，再给 `li` 赋一个 `默认值` 即可。

```python
def foo(li=None):
    if li is None:
        li = []
    li.append(1)
    print(li)

foo()
foo()
foo()
```

```
[1]
[1]
[1]
```

这样既不用担心 `可变类型` 作为函数 `默认参数` 时的副作用，也不用在每次调用 `foo` 函数时都传递一个参数进去，能够很好的解决这个问题。

所以，当我们给函数定义 `默认参数` 时，应该尽量使用 `不可变类型` 以免产生意想不到的副作用。当然，除非你明确知道你需要用 `可变类型` 的特性来达到某些目的。
