<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>在 Go 中为什么推荐使用空结构体作为 Context 的 key | 江湖十年 | 学而不思则罔，思而不学则殆。</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Go">
    <meta name="description" content="我曾在《Go 中空结构体惯用法，我帮你总结全了！》一文中介绍过空结构体的多种用法，本文再来补充一种惯用法：将空结构体作为 Context 的 key 来进行安全传值。">
<meta property="og:type" content="article">
<meta property="og:title" content="在 Go 中为什么推荐使用空结构体作为 Context 的 key">
<meta property="og:url" content="http://www.jianghushinian.cn/2025/06/08/empty-struct-as-key-of-ctx/index.html">
<meta property="og:site_name" content="江湖十年">
<meta property="og:description" content="我曾在《Go 中空结构体惯用法，我帮你总结全了！》一文中介绍过空结构体的多种用法，本文再来补充一种惯用法：将空结构体作为 Context 的 key 来进行安全传值。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-06-08T09:19:25.000Z">
<meta property="article:modified_time" content="2025-06-08T10:22:44.162Z">
<meta property="article:author" content="江湖十年">
<meta property="article:tag" content="Go">
<meta name="twitter:card" content="summary">
    
        <link rel="alternate" type="application/atom+xml" title="江湖十年" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">江湖十年</h5>
          <a href="mailto:jianghushinian007@outlook.com" title="jianghushinian007@outlook.com" class="mail">jianghushinian007@outlook.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-link"></i>
                关于
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/jianghushinian" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">在 Go 中为什么推荐使用空结构体作为 Context 的 key</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">在 Go 中为什么推荐使用空结构体作为 Context 的 key</h1>
        <h5 class="subtitle">
            
                <time datetime="2025-06-08T09:19:25.000Z" itemprop="datePublished" class="page-time">
  2025-06-08
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Go/">Go</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用-Context-进行传值"><span class="post-toc-number">1.</span> <span class="post-toc-text">使用 Context 进行传值</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#key-冲突问题"><span class="post-toc-number">2.</span> <span class="post-toc-text">key 冲突问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#解决-key-冲突问题"><span class="post-toc-number">3.</span> <span class="post-toc-text">解决 key 冲突问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用空结构体作为-key"><span class="post-toc-number">4.</span> <span class="post-toc-text">使用空结构体作为 key</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#空结构体作为-key-的错误用法"><span class="post-toc-number">5.</span> <span class="post-toc-text">空结构体作为 key 的错误用法</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用自定义类型作为-key"><span class="post-toc-number">6.</span> <span class="post-toc-text">使用自定义类型作为 key</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#项目实战"><span class="post-toc-number">7.</span> <span class="post-toc-text">项目实战</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#使用空结构体作为-key-在-Context-中传递事务"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">使用空结构体作为 key 在 Context 中传递事务</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#contextx-包"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">contextx 包</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#总结"><span class="post-toc-number">8.</span> <span class="post-toc-text">总结</span></a></li></ol>
        </nav>
    </aside>


<article id="post-empty-struct-as-key-of-ctx"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">在 Go 中为什么推荐使用空结构体作为 Context 的 key</h1>
        <div class="post-meta">
            <time class="post-time" title="2025-06-08 17:19:25" datetime="2025-06-08T09:19:25.000Z"  itemprop="datePublished">2025-06-08</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Go/">Go</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>我曾在《<a href="https://mp.weixin.qq.com/s/Qi0RrRyHLx8Q4SmhQeb-uQ" target="_blank" rel="noopener">Go 中空结构体惯用法，我帮你总结全了！</a>》一文中介绍过空结构体的多种用法，本文再来补充一种惯用法：将空结构体作为 Context 的 <code>key</code> 来进行安全传值。</p>
<a id="more"></a>

<blockquote>
<p>NOTE:</p>
<p>如果你对 Go 语言中的 Context 不够熟悉，可以阅读我的另一篇文章《<a href="https://mp.weixin.qq.com/s/wPXzISELBc33vjvxPvQY5w" target="_blank" rel="noopener">Go 并发控制：context 源码解读</a>》。</p>
</blockquote>
<h3 id="使用-Context-进行传值"><a href="#使用-Context-进行传值" class="headerlink" title="使用 Context 进行传值"></a>使用 Context 进行传值</h3><p>我们知道 Context 主要有两种用法，控制链路和安全传值。</p>
<p>在此我来演示下如何使用 Context 进行安全传值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requestIdKey = <span class="string">"request-id"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> 通过 context 传递 request id 信息</span></span><br><span class="line">	<span class="comment">// 设置值</span></span><br><span class="line">	ctx = context.WithValue(ctx, requestIdKey, <span class="string">"req-123"</span>)</span><br><span class="line">	<span class="comment">// 获取值</span></span><br><span class="line">	fmt.Printf(<span class="string">"request-id: %s\n"</span>, ctx.Value(requestIdKey))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 Context 进行传值的方式非常简单，<code>context.WithValue(ctx, key, value)</code> 函数可以为一个已存在的 <code>ctx</code> 对象，附加一个键值对（注意：这里的 <code>key</code> 和 <code>value</code> 都是 <code>any</code> 类型）。然后，可以使用 <code>ctx.Value(key)</code> 来获取 <code>key</code> 对应的 <code>value</code>。</p>
<p>这里我们使用字符串 <code>request-id</code> 作为 <code>key</code>，值为 <code>req-123</code>。</p>
<p>执行示例代码，得到输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go                                                            </span><br><span class="line">request-id: req-123</span><br></pre></td></tr></table></figure>

<p>题外话，之所以说 Context 可以进行安全传值，是因为它的源码实现是并发安全的，你可以在《<a href="https://mp.weixin.qq.com/s/wPXzISELBc33vjvxPvQY5w" target="_blank" rel="noopener">Go 并发控制：context 源码解读</a>》中学习其实现原理。</p>
<p>但是，从代码编写者的角度来说，通过 Context 传值并不都是“安全”的，咱们接着往下看。</p>
<h3 id="key-冲突问题"><a href="#key-冲突问题" class="headerlink" title="key 冲突问题"></a>key 冲突问题</h3><p>既然 Context 的 <code>key</code> 可以是任意类型，那么固然也可以是任意值。我们在写代码的时候，经常会用一些如 <code>i</code>、<code>info</code>、<code>data</code> 等作为变量，那么我们也很有可能使用 <code>data</code> 这样类似的字符串值作为 Context 的 <code>key</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> 这个 key 非常容易冲突</span></span><br><span class="line"><span class="keyword">const</span> dataKey = <span class="string">"data"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line"></span><br><span class="line">	ctx = context.WithValue(ctx, dataKey, <span class="string">"some data"</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"data: %s\n"</span>, ctx.Value(dataKey))</span><br><span class="line"></span><br><span class="line">	userDataKey := <span class="string">"data"</span> <span class="comment">// 与 dataKey 值相同</span></span><br><span class="line">	ctx = context.WithValue(ctx, userDataKey, <span class="string">"user data"</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"user data: %s\n"</span>, ctx.Value(userDataKey))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次查看 dataKey 的值</span></span><br><span class="line">	fmt.Printf(<span class="string">"data: %s\n"</span>, ctx.Value(dataKey))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>dataKey</code> 的值为 <code>data</code>，我们将其作为 <code>key</code> 存入 Context。稍后，又将 <code>userDataKey</code> 变量作为 Context 的 <code>key</code> 存入 Context。最终，<code>ctx.Value(dataKey)</code> 返回的值是什么呢？</p>
<p>执行示例代码，得到输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ data: some data</span><br><span class="line">user data: user data</span><br><span class="line">data: user data</span><br></pre></td></tr></table></figure>

<p>结果很明显，虽然 <code>dataKey</code> 和 <code>userDataKey</code> 这两个 <code>key</code> 的变量名不一样，但是它们的值同为 <code>data</code>，最终导致 <code>ctx.Value(dataKey)</code> 返回的结果与 <code>ctx.Value(userDataKey)</code> 返回结果相同。</p>
<p>即 <code>dataKey</code> 的值已经被 <code>userDataKey</code> 所覆盖。所以我才说，通过 Context 传值并不都是“安全”的，因为你的键值对可能会被覆盖。</p>
<h3 id="解决-key-冲突问题"><a href="#解决-key-冲突问题" class="headerlink" title="解决 key 冲突问题"></a>解决 key 冲突问题</h3><p>如何有效避免 Context 传值是 <code>key</code> 冲突的问题呢？</p>
<p>最简单的方案，就是为 <code>key</code> 定义一个具有业务属性的前缀，比如用户相关的数据 <code>key</code> 为 <code>user-data</code>，文章相关的数据 <code>key</code> 为 <code>post-data</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> 为了避免 key 冲突，我们通常可以为 key 定义一个业务属性的前缀</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	userDataKey = <span class="string">"user-data"</span></span><br><span class="line">	postDataKey = <span class="string">"post-data"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line"></span><br><span class="line">	ctx = context.WithValue(ctx, userDataKey, <span class="string">"user data"</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"user-data: %s\n"</span>, ctx.Value(userDataKey))</span><br><span class="line"></span><br><span class="line">	ctx = context.WithValue(ctx, postDataKey, <span class="string">"post data"</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"post-data: %s\n"</span>, ctx.Value(postDataKey))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行示例代码，得到输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">user-data: user data</span><br><span class="line">post-data: post data</span><br></pre></td></tr></table></figure>

<p>这样不同业务的 <code>key</code> 就不会互相干扰了。</p>
<p>你也许还想到了更好的方式，比如将所有 <code>key</code> 定义为常量，并统一放在一个叫 <code>constant</code> 的包中，这也是一种很常见的解决问题的方式。</p>
<p>但我个人极其不推荐这种做法，虽然表面上看将所有常量统一放在一个包中，集中管理，更方便维护。但当常量一多，这个包简直是灾难。Go 更推崇将代码中的变量、常量等定义在其使用的地方，而不是统一放在一个文件中管理，为自己增加心智负担。</p>
<p>其实我们还有更加优雅的解决办法，是时候让空结构体登场了。</p>
<h3 id="使用空结构体作为-key"><a href="#使用空结构体作为-key" class="headerlink" title="使用空结构体作为 key"></a>使用空结构体作为 key</h3><p>Context 的 <code>key</code> 可以是任意类型，那么空结构体就是绝佳方案。</p>
<p>我们可以使用空结构体定义一个自定义类型，然后作为 Context 的 <code>key</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> 使用空结构体作为 context key</span></span><br><span class="line"><span class="keyword">type</span> emptyKey <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> anotherEmpty <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line"></span><br><span class="line">	ctx = context.WithValue(ctx, emptyKey&#123;&#125;, <span class="string">"empty struct data"</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"empty data: %s\n"</span>, ctx.Value(emptyKey&#123;&#125;))</span><br><span class="line"></span><br><span class="line">	ctx = context.WithValue(ctx, anotherEmpty&#123;&#125;, <span class="string">"another empty struct data"</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"another empty data: %s\n"</span>, ctx.Value(anotherEmpty&#123;&#125;))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 再次查看 emptyKey 对应的 value</span></span><br><span class="line">	fmt.Printf(<span class="string">"empty data: %s\n"</span>, ctx.Value(emptyKey&#123;&#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行示例代码，得到输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">empty data: empty struct data</span><br><span class="line">another empty data: another empty struct data</span><br><span class="line">empty data: empty struct data</span><br></pre></td></tr></table></figure>

<p>这一次，没有出现覆盖情况。</p>
<h3 id="空结构体作为-key-的错误用法"><a href="#空结构体作为-key-的错误用法" class="headerlink" title="空结构体作为 key 的错误用法"></a>空结构体作为 key 的错误用法</h3><p>现在，我们来换一种用法，不再自定义新的类型，而是直接将空结构体变量作为 Context 的 <code>key</code>，示例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> 空结构体作为 context key 的错误用法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line"></span><br><span class="line">	key1 := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	ctx = context.WithValue(ctx, key1, <span class="string">"data1"</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"key1 data: %s\n"</span>, ctx.Value(key1))</span><br><span class="line"></span><br><span class="line">	key2 := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">	ctx = context.WithValue(ctx, key2, <span class="string">"data2"</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"key2 data: %s\n"</span>, ctx.Value(key2))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 再次查看 key1 对应的 value</span></span><br><span class="line">	fmt.Printf(<span class="string">"key1 data: %s\n"</span>, ctx.Value(key1))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行示例代码，得到输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">key1 data: data1</span><br><span class="line">key2 data: data2</span><br><span class="line">key1 data: data2</span><br></pre></td></tr></table></figure>

<p>可以发现，这次又出现了 <code>key2</code> 键值对覆盖 <code>key1</code> 键值对的情况。</p>
<p>所以，你有没有注意到，使用空结构体作为 Context 的 <code>key</code>，最关键的步骤，其实是要基于空结构体定义一个<strong>新的类型</strong>。我们使用这个<strong>新类型的实例对象</strong>作为 <code>key</code>，而不是直接使用空<strong>结构体变量</strong>作为 <code>key</code>，<strong>这二者是有本质区别的</strong>。</p>
<p>这是两个不同的类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyKey <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"><span class="keyword">type</span> anotherEmpty <span class="keyword">struct</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>它们相同点只不过是二者都没有属性和方法，都是一个空的结构体。</p>
<p>而 <code>emptyKey{}</code> 和 <code>anotherEmpty{}</code> 一定<strong>不相等</strong>，因为它们是<strong>不同的类型</strong>。</p>
<p>这是两个空结构体变量：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key1 := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">key2 := <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>显然，<code>key1</code> <strong>等于</strong> <code>key2</code>，因为它们的<strong>值相等</strong>，并且<strong>类型也相同</strong>。</p>
<p>有很多人看到将空结构体作为 Context 的 <code>key</code> 时，第一想法是担心冲突，以为空结构体作为 <code>key</code> 时只能保存一个键值对，设置多个键值对时，后面的空结构体 <code>key</code> 会覆盖之前的空结构体 <code>key</code>。</p>
<p>实则不然，每一个 <code>key</code> 都是一个新的类型，而非常量（<code>const</code>），这一点很重要，非常容易让人误解。</p>
<p>很多文章或教程并没有强调这一点，所以导致很多人看了教程以后，觉得这个特性没什么用，或产生困惑。其实这也是编程的魅力所在，编程是一门非常注重实操的学科，看一遍和写一遍完全是不同概念，这决定了你对某项技术理解程度。</p>
<h3 id="使用自定义类型作为-key"><a href="#使用自定义类型作为-key" class="headerlink" title="使用自定义类型作为 key"></a>使用自定义类型作为 key</h3><p>既然我们在使用空结构体作为 Context 的 <code>key</code> 时，是定义了一个新的类型，那么我们是否也可以使用其他自定义类型作为 Context 的 <code>key</code> 呢？</p>
<p>答案是肯定的，因为 Context 的 <code>key</code> 本身就是 <code>any</code> 类型。</p>
<p>使用基于 <code>string</code> 自定义类型，作为 Context 的 <code>key</code> 示例如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> 基于 string 自定义类型，作为 context key</span></span><br><span class="line"><span class="keyword">type</span> key1 <span class="keyword">string</span></span><br><span class="line"><span class="keyword">type</span> key2 <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx := context.Background()</span><br><span class="line"></span><br><span class="line">	ctx = context.WithValue(ctx, key1(<span class="string">""</span>), <span class="string">"data1"</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"key1 data: %s\n"</span>, ctx.Value(key1(<span class="string">""</span>)))</span><br><span class="line"></span><br><span class="line">	ctx = context.WithValue(ctx, key2(<span class="string">""</span>), <span class="string">"data2"</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"key2 data: %s\n"</span>, ctx.Value(key2(<span class="string">""</span>)))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 再次查看 key1 对应的 value</span></span><br><span class="line">	fmt.Printf(<span class="string">"key1 data: %s\n"</span>, ctx.Value(key1(<span class="string">""</span>)))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么你认为这段代码执行结果如何呢？这就交给你自行去测试了。</p>
<h3 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h3><p>上面介绍了几种可以作为 Context 的 <code>key</code> 进行传值的做法，有推荐做法，也有踩坑做法。</p>
<p>接下来我们一起看下真实的企业级项目 <a href="https://github.com/onexstack/onex" target="_blank" rel="noopener">OneX</a> 中是如何定义和使用 Context 进行安全传值的。</p>
<h4 id="使用空结构体作为-key-在-Context-中传递事务"><a href="#使用空结构体作为-key-在-Context-中传递事务" class="headerlink" title="使用空结构体作为 key 在 Context 中传递事务"></a>使用空结构体作为 key 在 Context 中传递事务</h4><p>OneX 中巧妙的使用了 Context 来传递 GORM 的事务对象 <code>tx</code>，其实现如下：</p>
<blockquote>
<p><a href="https://github.com/onexstack/onex/blob/feature/onex-v2/internal/usercenter/store/store.go#L40" target="_blank" rel="noopener">https://github.com/onexstack/onex/blob/feature/onex-v2/internal/usercenter/store/store.go#L40</a></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// transactionKey is the key used to store transaction context in context.Context.</span></span><br><span class="line"><span class="keyword">type</span> transactionKey <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewStore initializes a singleton instance of type IStore.</span></span><br><span class="line"><span class="comment">// It ensures that the datastore is only created once using sync.Once.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewStore</span><span class="params">(db *gorm.DB)</span> *<span class="title">datastore</span></span> &#123;</span><br><span class="line">	<span class="comment">// Initialize the singleton datastore instance only once.</span></span><br><span class="line">	once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		S = &amp;datastore&#123;db&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> S</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DB filters the database instance based on the input conditions (wheres).</span></span><br><span class="line"><span class="comment">// If no conditions are provided, the function returns the database instance</span></span><br><span class="line"><span class="comment">// from the context (transaction instance or core database instance).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(store *datastore)</span> <span class="title">DB</span><span class="params">(ctx context.Context, wheres ...where.Where)</span> *<span class="title">gorm</span>.<span class="title">DB</span></span> &#123;</span><br><span class="line">	db := store.core</span><br><span class="line">	<span class="comment">// Attempt to retrieve the transaction instance from the context.</span></span><br><span class="line">	<span class="keyword">if</span> tx, ok := ctx.Value(transactionKey&#123;&#125;).(*gorm.DB); ok &#123;</span><br><span class="line">		db = tx</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Apply each provided 'where' condition to the query.</span></span><br><span class="line">	<span class="keyword">for</span> _, whr := <span class="keyword">range</span> wheres &#123;</span><br><span class="line">		db = whr.Where(db)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> db</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TX starts a new transaction instance.</span></span><br><span class="line"><span class="comment">// nolint: fatcontext</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(store *datastore)</span> <span class="title">TX</span><span class="params">(ctx context.Context, fn <span class="keyword">func</span>(ctx context.Context)</span> <span class="title">error</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> store.core.WithContext(ctx).Transaction(</span><br><span class="line">		<span class="function"><span class="keyword">func</span><span class="params">(tx *gorm.DB)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">			ctx = context.WithValue(ctx, transactionKey&#123;&#125;, tx)</span><br><span class="line">			<span class="keyword">return</span> fn(ctx)</span><br><span class="line">		&#125;,</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OneX 的 <code>store</code> 层用来操作数据库进行 CRUD，你可以阅读令飞老师的《<a href="https://mp.weixin.qq.com/s/sYT4IhDoklGWZQ9btSB-qw" target="_blank" rel="noopener">简洁架构设计：如何设计一个合理的软件架构？</a>》这篇文章来了解 OneX 的架构设计。</p>
<p>在 <code>store</code> 的源码中定义了空结构体类型 <code>transactionKey</code> 作为 Context 的 <code>key</code>，在调用 <code>store.TX</code> 方法时，方法内部会将事务对象 <code>tx</code> 作为 <code>value</code> 保存到 Context 中。</p>
<p>在调用 <code>store.DB</code> 对数据库进行操作时，就会优先判断当前是否处于事务中，如果 <code>ctx.Value(transactionKey{})</code> 有值，则说明当前事务正在进行，使用 <code>tx</code> 对象继续操作，否则说明是一个简单的数据库操作，直接返回 <code>db</code> 对象。</p>
<p>使用示例如下：</p>
<blockquote>
<p><a href="https://github.com/onexstack/onex/blob/feature/onex-v2/internal/usercenter/biz/v1/user/user.go#L69" target="_blank" rel="noopener">https://github.com/onexstack/onex/blob/feature/onex-v2/internal/usercenter/biz/v1/user/user.go#L69</a></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create implements the Create method of the UserBiz.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *userBiz)</span> <span class="title">Create</span><span class="params">(ctx context.Context, rq *v1.CreateUserRequest)</span> <span class="params">(*v1.CreateUserResponse, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> userM model.UserM</span><br><span class="line">	_ = core.Copy(&amp;userM, rq) <span class="comment">// Copy request data to the User model.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Start a transaction for creating the user and secret.</span></span><br><span class="line">	err := b.store.TX(ctx, <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="comment">// Attempt to create the user in the data store.</span></span><br><span class="line">		<span class="keyword">if</span> err := b.store.User().Create(ctx, &amp;userM); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="comment">// Handle duplicate entry error for username.</span></span><br><span class="line">			match, _ := regexp.MatchString(<span class="string">"Duplicate entry '.*' for key 'username'"</span>, err.Error())</span><br><span class="line">			<span class="keyword">if</span> match &#123;</span><br><span class="line">				<span class="keyword">return</span> v1.ErrorUserAlreadyExists(<span class="string">"user %q already exists"</span>, userM.Username)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> v1.ErrorUserCreateFailed(<span class="string">"create user failed: %s"</span>, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Create a secret for the newly created user.</span></span><br><span class="line">		secretM := &amp;model.SecretM&#123;</span><br><span class="line">			UserID:      userM.UserID,</span><br><span class="line">			Name:        <span class="string">"generated"</span>,</span><br><span class="line">			Expires:     <span class="number">0</span>,</span><br><span class="line">			Description: <span class="string">"automatically generated when user is created"</span>,</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err := b.store.Secret().Create(ctx, secretM); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> v1.ErrorSecretCreateFailed(<span class="string">"create secret failed: %s"</span>, err.Error())</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err <span class="comment">// Return any error from the transaction.</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;v1.CreateUserResponse&#123;UserID: userM.UserID&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当创建用户对象 <code>user</code> 时，会同步创建一条 <code>secret</code> 记录，此时就用到了事务。</p>
<p><code>b.store.TX</code> 用来开启事务，<code>b.store.User().Create()</code> 创建 <code>user</code> 对象时，<code>Create()</code> 方法内部，其实会返回 <code>tx</code> 对象，对于<code>b.store.Secret().Create()</code> 的调用同理，这样就完成了事务操作。</p>
<p>OneX 实际上实现了一个泛型版本的 <code>Create()</code> 方法：</p>
<blockquote>
<p><a href="https://github.com/onexstack/onex/blob/feature/onex-v2/staging/src/github.com/onexstack/onexstack/pkg/store/store.go#L63" target="_blank" rel="noopener">https://github.com/onexstack/onex/blob/feature/onex-v2/staging/src/github.com/onexstack/onexstack/pkg/store/store.go#L63</a></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create inserts a new object into the database.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Store[T])</span> <span class="title">Create</span><span class="params">(ctx context.Context, obj *T)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err := s.db(ctx).Create(obj).Error; err != <span class="literal">nil</span> &#123;</span><br><span class="line">		s.logger.Error(ctx, err, <span class="string">"Failed to insert object into database"</span>, <span class="string">"object"</span>, obj)</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// db retrieves the database instance and applies the provided where conditions.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Store[T])</span> <span class="title">db</span><span class="params">(ctx context.Context, wheres ...where.Where)</span> *<span class="title">gorm</span>.<span class="title">DB</span></span> &#123;</span><br><span class="line">	dbInstance := s.storage.DB(ctx)</span><br><span class="line">	<span class="keyword">for</span> _, whr := <span class="keyword">range</span> wheres &#123;</span><br><span class="line">		<span class="keyword">if</span> whr != <span class="literal">nil</span> &#123;</span><br><span class="line">			dbInstance = whr.Where(dbInstance)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dbInstance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论是调用 <code>b.store.User().Create()</code>，还是调用 <code>b.store.Secret().Create()</code>，其实最终都会调用此方法，而 <code>s.db(ctx)</code> 内部又调用了 <code>s.storage.DB(ctx)</code>，这里的 <code>DB</code> 方法，其实就是 <code>*datastor.DB</code>。</p>
<p>至此，在 OneX 中使用空结构体作为 <code>key</code> 在 Context 中传递事务的主体脉络就理清了。如果你对 OneX 整体架构不够清晰，可能对这部分的讲解比较困惑，那么可以看看其源码，这是一个非常优秀的开源项目。</p>
<h4 id="contextx-包"><a href="#contextx-包" class="headerlink" title="contextx 包"></a>contextx 包</h4><p>此外，OneX 项目还专门抽象出一个 <code>contextx</code> 包，用来定义公共的 Context 操作。</p>
<p>比如可以使用 Context 传递 <code>userID</code>：</p>
<blockquote>
<p><a href="https://github.com/onexstack/onex/blob/feature/onex-v2/internal/pkg/contextx/contextx.go" target="_blank" rel="noopener">https://github.com/onexstack/onex/blob/feature/onex-v2/internal/pkg/contextx/contextx.go</a></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">	userKey        <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">	...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// WithUserID put userID into context.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithUserID</span><span class="params">(ctx context.Context, userID <span class="keyword">string</span>)</span> <span class="title">context</span>.<span class="title">Context</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> context.WithValue(ctx, userKey&#123;&#125;, userID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserID extract userID from context.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UserID</span><span class="params">(ctx context.Context)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	userID, _ := ctx.Value(userKey&#123;&#125;).(<span class="keyword">string</span>)</span><br><span class="line">	<span class="keyword">return</span> userID</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>contextx</code> 包中有很多类似实现，你可以查看源码学习更多使用技巧。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文讲解了在 Go 中使用空结构体作为 Context 的 <code>key</code> 进行安全传值的小技巧。虽然这是一个不太起眼的小技巧，并且面试中也不会被问到，但正是这些微小的细节，决定了你写的代码最终质量。如果你想写出优秀的项目，那么每一个细节都值得深入思考，找到更优解。</p>
<p>使用 Context 对象传值时，其 <code>key</code> 可以是任意类型，那么为什么使用空结构体是更好的选择呢？因为空结构体不占内存空间，并且满足了唯一性的要求，所以空结构体是最优解。</p>
<p>并且，我们还可以像 <code>contextx</code> 包那样，将常用的传值操作放在一起，对外只暴露 <code>Set/Get</code> 两个方法，而将 Context 的 <code>key</code> 定义为<strong>未导出（unexported）类型</strong>，那么就不可能出现 <code>key</code> 冲突的情况。</p>
<p>当然，我们应该尽量避免使用 Context 来传递值，只在必要时使用。显式胜于隐式，当隐式代码变多，也将是灾难。</p>
<p>本文示例源码我都放在了 <a href="https://github.com/jianghushinian/blog-go-example/tree/main/struct/empty/context-key" target="_blank" rel="noopener">GitHub</a> 中，欢迎点击查看。</p>
<p>希望此文能对你有所启发。</p>
<p><strong>延伸阅读</strong></p>
<ul>
<li>Go 中空结构体惯用法，我帮你总结全了！：<a href="https://mp.weixin.qq.com/s/Qi0RrRyHLx8Q4SmhQeb-uQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Qi0RrRyHLx8Q4SmhQeb-uQ</a></li>
<li>Go 并发控制：context 源码解读：<a href="https://mp.weixin.qq.com/s/wPXzISELBc33vjvxPvQY5w" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/wPXzISELBc33vjvxPvQY5w</a></li>
<li>Golang Tip #37: Using Unexported Empty Struct as Context Key：<a href="https://x.com/func25/status/1763897057511899516" target="_blank" rel="noopener">https://x.com/func25/status/1763897057511899516</a></li>
<li>OneX GitHub 源码：<a href="https://github.com/onexstack/onex" target="_blank" rel="noopener">https://github.com/onexstack/onex</a></li>
<li>简洁架构设计：如何设计一个合理的软件架构？：<a href="https://mp.weixin.qq.com/s/sYT4IhDoklGWZQ9btSB-qw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/sYT4IhDoklGWZQ9btSB-qw</a></li>
<li>本文 GitHub 示例代码：<a href="https://github.com/jianghushinian/blog-go-example/tree/main/struct/empty/context-key" target="_blank" rel="noopener">https://github.com/jianghushinian/blog-go-example/tree/main/struct/empty/context-key</a></li>
<li>本文永久地址：<a href="https://jianghushinian.cn/2025/06/08/empty-struct-as-key-of-ctx/" target="_blank" rel="noopener">https://jianghushinian.cn/2025/06/08/empty-struct-as-key-of-ctx/</a></li>
</ul>
<p><strong>联系我</strong></p>
<ul>
<li>公众号：<a href="https://jianghushinian.cn/about" target="_blank" rel="noopener">Go编程世界</a></li>
<li>微信：jianghushinian</li>
<li>邮箱：<a href="mailto:jianghushinian007@outlook.com">jianghushinian007@outlook.com</a></li>
<li>博客：<a href="https://jianghushinian.cn" target="_blank" rel="noopener">https://jianghushinian.cn</a></li>
<li>GitHub：<a href="https://github.com/jianghushinian" target="_blank" rel="noopener">https://github.com/jianghushinian</a></li>
</ul>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2025-06-08T10:22:44.162Z" itemprop="dateUpdated">2025-06-08 18:22:44</time>
</span><br>


        
        <a href="/2025/06/08/empty-struct-as-key-of-ctx/" target="_blank" rel="external">http://www.jianghushinian.cn/2025/06/08/empty-struct-as-key-of-ctx/</a>
        
    </div>
    
    <footer>
        <a href="http://www.jianghushinian.cn">
            <img src="/img/avatar.png" alt="江湖十年">
            江湖十年
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/" rel="tag">Go</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://www.jianghushinian.cn/2025/06/08/empty-struct-as-key-of-ctx/&title=《在 Go 中为什么推荐使用空结构体作为 Context 的 key》 — 江湖十年&pic=http://www.jianghushinian.cn/img/avatar.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.jianghushinian.cn/2025/06/08/empty-struct-as-key-of-ctx/&title=《在 Go 中为什么推荐使用空结构体作为 Context 的 key》 — 江湖十年&source=我曾在《Go 中空结构体惯用法，我帮你总结全了！》一文中介绍过空结构体的多种用法，本文再来补充一种惯用法：将空结构体作为 Context 的 key 来进..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://www.jianghushinian.cn/2025/06/08/empty-struct-as-key-of-ctx/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《在 Go 中为什么推荐使用空结构体作为 Context 的 key》 — 江湖十年&url=http://www.jianghushinian.cn/2025/06/08/empty-struct-as-key-of-ctx/&via=http://www.jianghushinian.cn" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://www.jianghushinian.cn/2025/06/08/empty-struct-as-key-of-ctx/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/2025/06/01/fsm-source-code/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">Go 语言 fsm 源码解读，这一次让你彻底学会有限状态机</h4>
      </a>
    </div>
  
</nav>



    


    <script src="/js/md5.min.js"></script>
    <section class="comments" id="comments">
        <div id="disqus_thread"></div>
        <script type="text/javascript">
            var disqus_shortname = 'https-jianghushinian-cn';
            var disqus_identifier = location.pathname.slice(1,);
            var disqus_url = 'https://jianghushinian.cn/' + disqus_identifier;
            (function () {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the comments.</noscript>
    </section>


















</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        <span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        <span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>江湖十年 &copy; 2019 - 2025</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://www.jianghushinian.cn/2025/06/08/empty-struct-as-key-of-ctx/&title=《在 Go 中为什么推荐使用空结构体作为 Context 的 key》 — 江湖十年&pic=http://www.jianghushinian.cn/img/avatar.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.jianghushinian.cn/2025/06/08/empty-struct-as-key-of-ctx/&title=《在 Go 中为什么推荐使用空结构体作为 Context 的 key》 — 江湖十年&source=我曾在《Go 中空结构体惯用法，我帮你总结全了！》一文中介绍过空结构体的多种用法，本文再来补充一种惯用法：将空结构体作为 Context 的 key 来进..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://www.jianghushinian.cn/2025/06/08/empty-struct-as-key-of-ctx/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《在 Go 中为什么推荐使用空结构体作为 Context 的 key》 — 江湖十年&url=http://www.jianghushinian.cn/2025/06/08/empty-struct-as-key-of-ctx/&via=http://www.jianghushinian.cn" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://www.jianghushinian.cn/2025/06/08/empty-struct-as-key-of-ctx/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://www.jianghushinian.cn/2025/06/08/empty-struct-as-key-of-ctx/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
