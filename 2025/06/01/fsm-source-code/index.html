<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>Go 语言 fsm 源码解读，这一次让你彻底学会有限状态机 | 江湖十年 | 学而不思则罔，思而不学则殆。</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="Go,有限状态机,FSM">
    <meta name="description" content="我在文章《在 Go 中如何使用有限状态机优雅解决程序中状态转换问题》中讲解了有限状态机的概念，并介绍了 Go 中有限状态机 fsm 包的使用。本篇文章，我将更进一步，直接通过解读源码的方式，让你深刻理解 fsm 是如何实现的，这一次你将彻底掌握有限状态机。">
<meta property="og:type" content="article">
<meta property="og:title" content="Go 语言 fsm 源码解读，这一次让你彻底学会有限状态机">
<meta property="og:url" content="http://www.jianghushinian.cn/2025/06/01/fsm-source-code/index.html">
<meta property="og:site_name" content="江湖十年">
<meta property="og:description" content="我在文章《在 Go 中如何使用有限状态机优雅解决程序中状态转换问题》中讲解了有限状态机的概念，并介绍了 Go 中有限状态机 fsm 包的使用。本篇文章，我将更进一步，直接通过解读源码的方式，让你深刻理解 fsm 是如何实现的，这一次你将彻底掌握有限状态机。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.jianghushinian.cn/2025/06/01/fsm-source-code/fsm.jpg">
<meta property="og:image" content="http://www.jianghushinian.cn/2025/06/01/fsm-source-code/fsm-methods.jpg">
<meta property="og:image" content="http://www.jianghushinian.cn/2025/06/01/fsm-source-code/fsm-event1.jpg">
<meta property="og:image" content="http://www.jianghushinian.cn/2025/06/01/fsm-source-code/fsm-event2.jpg">
<meta property="og:image" content="http://www.jianghushinian.cn/2025/06/01/fsm-source-code/fsm-event3.jpg">
<meta property="og:image" content="http://www.jianghushinian.cn/2025/06/01/fsm-source-code/fsm-event4.jpg">
<meta property="article:published_time" content="2025-06-01T08:48:08.000Z">
<meta property="article:modified_time" content="2025-06-01T09:58:40.260Z">
<meta property="article:author" content="江湖十年">
<meta property="article:tag" content="Go">
<meta property="article:tag" content="有限状态机">
<meta property="article:tag" content="FSM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.jianghushinian.cn/2025/06/01/fsm-source-code/fsm.jpg">
    
        <link rel="alternate" type="application/atom+xml" title="江湖十年" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.png">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">江湖十年</h5>
          <a href="mailto:jianghushinian007@outlook.com" title="jianghushinian007@outlook.com" class="mail">jianghushinian007@outlook.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-link"></i>
                关于
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/jianghushinian" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">Go 语言 fsm 源码解读，这一次让你彻底学会有限状态机</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">Go 语言 fsm 源码解读，这一次让你彻底学会有限状态机</h1>
        <h5 class="subtitle">
            
                <time datetime="2025-06-01T08:48:08.000Z" itemprop="datePublished" class="page-time">
  2025-06-01
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Go/">Go</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#源码解读"><span class="post-toc-number">1.</span> <span class="post-toc-text">源码解读</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#结构体"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">结构体</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#方法"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">方法</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#构造函数"><span class="post-toc-number">1.2.1.</span> <span class="post-toc-text">构造函数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#当前状态"><span class="post-toc-number">1.2.2.</span> <span class="post-toc-text">当前状态</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#状态转换"><span class="post-toc-number">1.2.3.</span> <span class="post-toc-text">状态转换</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#回调函数"><span class="post-toc-number">1.2.4.</span> <span class="post-toc-text">回调函数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#元信息"><span class="post-toc-number">1.2.5.</span> <span class="post-toc-text">元信息</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#使用示例"><span class="post-toc-number">2.</span> <span class="post-toc-text">使用示例</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#元信息使用"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">元信息使用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#异步示例"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">异步示例</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#总结"><span class="post-toc-number">3.</span> <span class="post-toc-text">总结</span></a></li></ol>
        </nav>
    </aside>


<article id="post-fsm-source-code"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">Go 语言 fsm 源码解读，这一次让你彻底学会有限状态机</h1>
        <div class="post-meta">
            <time class="post-time" title="2025-06-01 16:48:08" datetime="2025-06-01T08:48:08.000Z"  itemprop="datePublished">2025-06-01</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Go/">Go</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>我在文章《<a href="https://jianghushinian.cn/2025/05/25/fsm/" target="_blank" rel="noopener">在 Go 中如何使用有限状态机优雅解决程序中状态转换问题</a>》中讲解了有限状态机的概念，并介绍了 Go 中有限状态机 <a href="https://github.com/looplab/fsm" target="_blank" rel="noopener">fsm</a> 包的使用。本篇文章，我将更进一步，直接通过解读源码的方式，让你深刻理解 fsm 是如何实现的，这一次你将彻底掌握有限状态机。</p>
<a id="more"></a>

<h3 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h3><p>废话不多说，我们直接上代码。</p>
<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p>首先 fsm 包定义了一个结构体 <code>FSM</code> 用来表示状态机。</p>
<blockquote>
<p><a href="https://github.com/looplab/fsm/blob/main/fsm.go#L40" target="_blank" rel="noopener">https://github.com/looplab/fsm/blob/main/fsm.go#L40</a></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FSM 是持有「当前状态」的状态机。</span></span><br><span class="line"><span class="keyword">type</span> FSM <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// FSM 当前状态</span></span><br><span class="line">	current <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// transitions 将「事件和原状态」映射到「目标状态」。</span></span><br><span class="line">	transitions <span class="keyword">map</span>[eKey]<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// callbacks 将「回调类型和目标」映射到「回调函数」。</span></span><br><span class="line">	callbacks <span class="keyword">map</span>[cKey]Callback</span><br><span class="line"></span><br><span class="line">	<span class="comment">// transition 是内部状态转换函数，可以直接使用，也可以在异步状态转换时调用。</span></span><br><span class="line">	transition <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line">	<span class="comment">// transitionerObj 用于调用 FSM 的 transition() 函数。</span></span><br><span class="line">	transitionerObj transitioner</span><br><span class="line"></span><br><span class="line">	<span class="comment">// stateMu 保护对当前状态的访问。</span></span><br><span class="line">	stateMu sync.RWMutex</span><br><span class="line">	<span class="comment">// eventMu 保护对 Event() 和 Transition() 两个函数的调用。</span></span><br><span class="line">	eventMu sync.Mutex</span><br><span class="line"></span><br><span class="line">	<span class="comment">// metadata 可以用来存储和加载可能跨事件使用的数据</span></span><br><span class="line">	<span class="comment">// 使用 SetMetadata() 和 Metadata() 方法来存储和加载数据。</span></span><br><span class="line">	metadata <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// metadataMu 保护对元数据的访问。</span></span><br><span class="line">	metadataMu sync.RWMutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们知道，有限状态机中最重要的三个特征如下：</p>
<ul>
<li><font style="color:rgb(33, 33, 33);">状态（state）个数是有限的。</font></li>
<li><font style="color:rgb(33, 33, 33);">任意一个时刻，只处于其中一种状态。</font></li>
<li><font style="color:rgb(33, 33, 33);">某种条件下（触发某种 event），会从一种状态转变（transition）为另一种状态。</font></li>
</ul>
<p><font style="color:rgb(33, 33, 33);">所以，</font><code>&lt;font style=&quot;color:rgb(33, 33, 33);&quot;&gt;FSM&lt;/font&gt;</code><font style="color:rgb(33, 33, 33);"> 结构体中一定包含与这些特征有关的字段。</font></p>
<p><code>current</code> 表示状态机的当前状态。</p>
<p><code>transitions</code> 用于记录状态转换规则，即定义触发某一事件时，允许从某一种状态，转换成另一种状态。它是一个 <code>map</code> 对象，其 <code>key</code> 为 <code>eKey</code> 类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eKey is a struct key used for storing the transition map.</span></span><br><span class="line"><span class="keyword">type</span> eKey <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// event is the name of the event that the keys refers to.</span></span><br><span class="line">	event <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// src is the source from where the event can transition.</span></span><br><span class="line">	src <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>eKey</code> 类型用来记录事件和原状态。<code>map</code> 的 <code>value</code> 为 <code>string</code> 类型，用来记录目标状态。</p>
<p><code>callbacks</code> 用于记录事件触发时的回调函数。它也是一个 <code>map</code> 对象，其 <code>key</code> 为 <code>cKey</code> 类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cKey is a struct key used for keeping the callbacks mapped to a target.</span></span><br><span class="line"><span class="keyword">type</span> cKey <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// target is either the name of a state or an event depending on which</span></span><br><span class="line">	<span class="comment">// callback type the key refers to. It can also be "" for a non-targeted</span></span><br><span class="line">	<span class="comment">// callback like before_event.</span></span><br><span class="line">	target <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// callbackType is the situation when the callback will be run.</span></span><br><span class="line">	callbackType <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>cKey</code> 类型用来记录目标和回调类型，其中目标可以是<strong>状态</strong>或<strong>事件</strong>名称，回调类型可选值如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// 未设置回调</span></span><br><span class="line">	callbackNone <span class="keyword">int</span> = <span class="literal">iota</span></span><br><span class="line">	<span class="comment">// 事件触发前执行的回调</span></span><br><span class="line">	callbackBeforeEvent</span><br><span class="line">	<span class="comment">// 离开旧状态前执行的回调</span></span><br><span class="line">	callbackLeaveState</span><br><span class="line">	<span class="comment">// 进入新状态是执行的回调</span></span><br><span class="line">	callbackEnterState</span><br><span class="line">	<span class="comment">// 事件完成时执行的回调</span></span><br><span class="line">	callbackAfterEvent</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>回调类型决定了回调函数的执行时机。</p>
<p>map 的 value 为回调函数，其声明类型如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callback is a function type that callbacks should use. Event is the current</span></span><br><span class="line"><span class="comment">// event info as the callback happens.</span></span><br><span class="line"><span class="keyword">type</span> Callback <span class="function"><span class="keyword">func</span><span class="params">(context.Context, *Event)</span></span></span><br></pre></td></tr></table></figure>

<p>还记得回调函数是如何注册的吗？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fsm.Callbacks&#123;</span><br><span class="line">	<span class="comment">// 任一事件发生之前触发</span></span><br><span class="line">	<span class="string">"before_event"</span>: <span class="function"><span class="keyword">func</span><span class="params">(_ context.Context, e *fsm.Event)</span></span> &#123;</span><br><span class="line">		color.HiMagenta(<span class="string">"| before event\t | %s | %s |"</span>, e.Src, e.Dst)</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里注册的 <code>before_event</code> 回调函数签名就是 <code>Callback</code> 类型。</p>
<p>当然这里还使用了 <code>fsm.Callbacks</code> 类型来注册，想必你已经猜到了 <code>fsm.Callbacks</code> 的类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callbacks is a shorthand for defining the callbacks in NewFSM.</span></span><br><span class="line"><span class="keyword">type</span> Callbacks <span class="keyword">map</span>[<span class="keyword">string</span>]Callback</span><br></pre></td></tr></table></figure>

<p>接下来的 <code>transition</code> 和 <code>transitionerObj</code> 两个属性是用来实现状态转换的，暂且留到后续使用时再来研究。</p>
<p>这里还有两个互斥锁，分别用来保护对当前状态的访问（<code>stateMu</code>），和保证事件触发时的操作并发安全（<code>eventMu</code>）。</p>
<p>最后 FSM 还提供了 <code>metadata</code> 和 <code>metadataMu</code> 两个属性，这俩属性用于管理元数据信息，后文中我会演示其使用场景。</p>
<p>现在，我们可以总结一下 <code>FSM</code> 结构体定义：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="fsm.jpg" alt="FSM" title="">
                </div>
                <div class="image-caption">FSM</div>
            </figure>

<p>接下来，我将对 <code>FSM</code> 结构体所实现的方法进行讲解。</p>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>我们先来看一下 <code>FSM</code> 结构体都提供了哪些方法和能力：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="fsm-methods.jpg" alt="FSM" title="">
                </div>
                <div class="image-caption">FSM</div>
            </figure>

<p>这里列出了 <code>FSM</code> 结构体实现的所有方法，并且做了分类，你先有个感官上的认识，接下来我们依次解读。</p>
<h5 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h5><p>我们最先要分析的源码，当然是 <code>FSM</code> 结构体的构造函数了，其实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewFSM</span><span class="params">(initial <span class="keyword">string</span>, events []EventDesc, callbacks <span class="keyword">map</span>[<span class="keyword">string</span>]Callback)</span> *<span class="title">FSM</span></span> &#123;</span><br><span class="line">	<span class="comment">// 构造有限状态机 FSM</span></span><br><span class="line">	f := &amp;FSM&#123;</span><br><span class="line">		transitionerObj: &amp;transitionerStruct&#123;&#125;,        <span class="comment">// 状态转换器，使用默认实现</span></span><br><span class="line">		current:         initial,                      <span class="comment">// 当前状态</span></span><br><span class="line">		transitions:     <span class="built_in">make</span>(<span class="keyword">map</span>[eKey]<span class="keyword">string</span>),        <span class="comment">// 存储「事件和原状态」到「目标状态」的转换规则映射</span></span><br><span class="line">		callbacks:       <span class="built_in">make</span>(<span class="keyword">map</span>[cKey]Callback),      <span class="comment">// 回调函数映射表</span></span><br><span class="line">		metadata:        <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;), <span class="comment">// 元信息</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 构建 f.transitions map，并且存储所有的「事件」和「状态」集合</span></span><br><span class="line">	allEvents := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>) <span class="comment">// 存储所有事件的集合</span></span><br><span class="line">	allStates := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>) <span class="comment">// 存储所有状态的集合</span></span><br><span class="line">	<span class="keyword">for</span> _, e := <span class="keyword">range</span> events &#123;         <span class="comment">// 遍历事件列表，提取并存储所有事件和状态</span></span><br><span class="line">		<span class="keyword">for</span> _, src := <span class="keyword">range</span> e.Src &#123;</span><br><span class="line">			f.transitions[eKey&#123;e.Name, src&#125;] = e.Dst</span><br><span class="line">			allStates[src] = <span class="literal">true</span></span><br><span class="line">			allStates[e.Dst] = <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		allEvents[e.Name] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 提取「回调函数」到「事件和原状态」的映射关系，并注册到 callbacks</span></span><br><span class="line">	<span class="keyword">for</span> name, fn := <span class="keyword">range</span> callbacks &#123;</span><br><span class="line">		<span class="keyword">var</span> target <span class="keyword">string</span>    <span class="comment">// 目标：状态/事件</span></span><br><span class="line">		<span class="keyword">var</span> callbackType <span class="keyword">int</span> <span class="comment">// 回调类型（决定了调用顺序）</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 根据回调函数名称前缀分类</span></span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="comment">// 事件触发前执行</span></span><br><span class="line">		<span class="keyword">case</span> strings.HasPrefix(name, <span class="string">"before_"</span>):</span><br><span class="line">			target = strings.TrimPrefix(name, <span class="string">"before_"</span>)</span><br><span class="line">			<span class="keyword">if</span> target == <span class="string">"event"</span> &#123; <span class="comment">// 全局事件前置钩子（任何事件触发都会调用，如用于日志记录场景）</span></span><br><span class="line">				target = <span class="string">""</span> <span class="comment">// 将 target 置空</span></span><br><span class="line">				callbackType = callbackBeforeEvent</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> _, ok := allEvents[target]; ok &#123; <span class="comment">// 在特定事件前执行</span></span><br><span class="line">				callbackType = callbackBeforeEvent</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">// 离开当前状态前执行</span></span><br><span class="line">		<span class="keyword">case</span> strings.HasPrefix(name, <span class="string">"leave_"</span>):</span><br><span class="line">			target = strings.TrimPrefix(name, <span class="string">"leave_"</span>)</span><br><span class="line">			<span class="keyword">if</span> target == <span class="string">"state"</span> &#123; <span class="comment">// 全局状态离开钩子</span></span><br><span class="line">				target = <span class="string">""</span></span><br><span class="line">				callbackType = callbackLeaveState</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> _, ok := allStates[target]; ok &#123; <span class="comment">// 离开旧状态前执行</span></span><br><span class="line">				callbackType = callbackLeaveState</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">// 进入新状态后执行</span></span><br><span class="line">		<span class="keyword">case</span> strings.HasPrefix(name, <span class="string">"enter_"</span>):</span><br><span class="line">			target = strings.TrimPrefix(name, <span class="string">"enter_"</span>)</span><br><span class="line">			<span class="keyword">if</span> target == <span class="string">"state"</span> &#123; <span class="comment">// 全局状态进入钩子</span></span><br><span class="line">				target = <span class="string">""</span></span><br><span class="line">				callbackType = callbackEnterState</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> _, ok := allStates[target]; ok &#123; <span class="comment">// 进入新状态后执行</span></span><br><span class="line">				callbackType = callbackEnterState</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">// 事件完成后执行</span></span><br><span class="line">		<span class="keyword">case</span> strings.HasPrefix(name, <span class="string">"after_"</span>):</span><br><span class="line">			target = strings.TrimPrefix(name, <span class="string">"after_"</span>)</span><br><span class="line">			<span class="keyword">if</span> target == <span class="string">"event"</span> &#123; <span class="comment">// 全局事件后置钩子</span></span><br><span class="line">				target = <span class="string">""</span></span><br><span class="line">				callbackType = callbackAfterEvent</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> _, ok := allEvents[target]; ok &#123; <span class="comment">// 事件完成后执行</span></span><br><span class="line">				callbackType = callbackAfterEvent</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">// 处理未加前缀的回调（简短版本）</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			target = name                       <span class="comment">// 状态/事件</span></span><br><span class="line">			<span class="keyword">if</span> _, ok := allStates[target]; ok &#123; <span class="comment">// 如果 target 为某个状态，则 callbackType 会置为与 enter_[target] 相同</span></span><br><span class="line">				callbackType = callbackEnterState</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> _, ok := allEvents[target]; ok &#123; <span class="comment">// 如果 target 为某个事件，则 callbackType 会置为与 after_[target] 相同</span></span><br><span class="line">				callbackType = callbackAfterEvent</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 记录 callbacks map</span></span><br><span class="line">		<span class="keyword">if</span> callbackType != callbackNone &#123;</span><br><span class="line">			<span class="comment">// key: callbackType（用于决定执行顺序） + target（如果是全局钩子，则 target 为空，否则，target 为状态/事件）</span></span><br><span class="line">			<span class="comment">// val: 事件触发时需要执行的回调函数</span></span><br><span class="line">			f.callbacks[cKey&#123;target, callbackType&#125;] = fn</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造函数内部代码比较多，我们可以将它的核心逻辑分为 3 块，分别是：构造有限状态机 <code>FSM</code>、记录事件（event）和状态（state）、注册回调函数。</p>
<p>构造有限状态机 <code>FSM</code> 部分的代码比较简单：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造有限状态机 FSM</span></span><br><span class="line">f := &amp;FSM&#123;</span><br><span class="line">	transitionerObj: &amp;transitionerStruct&#123;&#125;,        <span class="comment">// 状态转换器，使用默认实现</span></span><br><span class="line">	current:         initial,                      <span class="comment">// 当前状态</span></span><br><span class="line">	transitions:     <span class="built_in">make</span>(<span class="keyword">map</span>[eKey]<span class="keyword">string</span>),        <span class="comment">// 存储「事件和原状态」到「目标状态」的转换规则映射</span></span><br><span class="line">	callbacks:       <span class="built_in">make</span>(<span class="keyword">map</span>[cKey]Callback),      <span class="comment">// 回调函数映射表</span></span><br><span class="line">	metadata:        <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;), <span class="comment">// 元信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用函数参数 <code>initial</code> 作为状态机的当前状态，几个 <code>map</code> 类型的属性，都赋予了默认值。</p>
<p>接下来的部分代码逻辑用于记录事件（event）和状态（state）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建 f.transitions map，并且存储所有的「事件」和「状态」集合</span></span><br><span class="line">allEvents := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>) <span class="comment">// 存储所有事件的集合</span></span><br><span class="line">allStates := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>) <span class="comment">// 存储所有状态的集合</span></span><br><span class="line"><span class="keyword">for</span> _, e := <span class="keyword">range</span> events &#123;         <span class="comment">// 遍历事件列表，提取并存储所有事件和状态</span></span><br><span class="line">	<span class="keyword">for</span> _, src := <span class="keyword">range</span> e.Src &#123;</span><br><span class="line">		f.transitions[eKey&#123;e.Name, src&#125;] = e.Dst</span><br><span class="line">		allStates[src] = <span class="literal">true</span></span><br><span class="line">		allStates[e.Dst] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	allEvents[e.Name] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 <code>allEvents</code> 和 <code>allStates</code> 都是集合类型（Set），分别用于记录所有注册的事件和状态。</p>
<p>最后这一部分代码用来注册回调函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name, fn := <span class="keyword">range</span> callbacks &#123;</span><br><span class="line">	<span class="keyword">var</span> target <span class="keyword">string</span>    <span class="comment">// 目标：状态/事件</span></span><br><span class="line">	<span class="keyword">var</span> callbackType <span class="keyword">int</span> <span class="comment">// 回调类型（决定了调用顺序）</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 根据回调函数名称前缀分类</span></span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="comment">// 事件触发前执行</span></span><br><span class="line">	<span class="keyword">case</span> strings.HasPrefix(name, <span class="string">"before_"</span>):</span><br><span class="line">		target = strings.TrimPrefix(name, <span class="string">"before_"</span>)</span><br><span class="line">		<span class="keyword">if</span> target == <span class="string">"event"</span> &#123; <span class="comment">// 全局事件前置钩子（任何事件触发都会调用，如用于日志记录场景）</span></span><br><span class="line">			target = <span class="string">""</span> <span class="comment">// 将 target 置空</span></span><br><span class="line">			callbackType = callbackBeforeEvent</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> _, ok := allEvents[target]; ok &#123; <span class="comment">// 在特定事件前执行</span></span><br><span class="line">			callbackType = callbackBeforeEvent</span><br><span class="line">		&#125;</span><br><span class="line">	...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 记录 callbacks map</span></span><br><span class="line">	<span class="keyword">if</span> callbackType != callbackNone &#123;</span><br><span class="line">		<span class="comment">// key: callbackType（用于决定执行顺序） + target（如果是全局钩子，则 target 为空，否则，target 为状态/事件）</span></span><br><span class="line">		<span class="comment">// val: 事件触发时需要执行的回调函数</span></span><br><span class="line">		f.callbacks[cKey&#123;target, callbackType&#125;] = fn</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里遍历了 <code>callbacks</code> 列表，并根据回调函数名称前缀分类，然后注册到 <code>f.callbacks</code> 属性的 <code>map</code> 对象中。</p>
<blockquote>
<p>NOTE:</p>
<p>代码注释中的“钩子”就代表回调函数，只不过是另一种叫法罢了。</p>
</blockquote>
<p>我们再来回顾一下回调函数是如何注册的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fsm.Callbacks&#123;</span><br><span class="line">    <span class="string">"before_event"</span>: <span class="function"><span class="keyword">func</span><span class="params">(_ context.Context, e *fsm.Event)</span></span> &#123; ... &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个参数被传入构造函数后，会进入 <code>strings.HasPrefix(name, &quot;before_&quot;)</code> 这个 case，然后 <code>if target == &quot;event&quot;</code> 成立，此时 <code>target</code> 将会被置空，回调类型 <code>callbackType</code> 将被赋值为 <code>callbackBeforeEvent</code>。如果我们注册的是 <code>before_closed</code> 回调函数，则 <code>target</code> 值为 <code>closed</code>。对于 <code>target</code> 不同处理，<strong>将决定最后回调函数的执行顺序</strong>。我们暂且不继续深入，留个悬念，后续解读回调函数相关的源码，你就能白为什么了。</p>
<p>不过，我还要特别强调一下 <code>default</code> 分支的 case：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	target = name                       <span class="comment">// 状态/事件</span></span><br><span class="line">	<span class="keyword">if</span> _, ok := allStates[target]; ok &#123; <span class="comment">// 如果 target 为某个状态，则 callbackType 会置为与 enter_[target] 相同，即二者等价</span></span><br><span class="line">		callbackType = callbackEnterState</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> _, ok := allEvents[target]; ok &#123; <span class="comment">// 如果 target 为某个事件，则 callbackType 会置为与 after_[target] 相同，即二者等价</span></span><br><span class="line">		callbackType = callbackAfterEvent</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还记得在上一篇文章中我提到过，注册 <code>closed</code> 事件等价于 <code>enter_closed</code> 事件吗？就是在 <code>default</code> 这个 case 中实现的。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="fsm-event1.jpg" alt="FSM Event" title="">
                </div>
                <div class="image-caption">FSM Event</div>
            </figure>

<p>对于构造函数的讲解就到这里，里面一些具体的代码细节你可能现在有点发懵，没关系，接着往下看，你的疑惑都将被解开。</p>
<h5 id="当前状态"><a href="#当前状态" class="headerlink" title="当前状态"></a>当前状态</h5><p>接着，我们来看一下与当前状态相关的这几个方法源码是如何实现的，它们的代码其实都很简单，我就不一一解读了，我把源码贴在这里，你一看就能明白：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Current 返回 FSM 的当前状态。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">Current</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	f.stateMu.RLock()</span><br><span class="line">	<span class="keyword">defer</span> f.stateMu.RUnlock()</span><br><span class="line">	<span class="keyword">return</span> f.current</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Is 判断 FSM 当前状态是否为指定状态。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">Is</span><span class="params">(state <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	f.stateMu.RLock()</span><br><span class="line">	<span class="keyword">defer</span> f.stateMu.RUnlock()</span><br><span class="line">	<span class="keyword">return</span> state == f.current</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetState 将 FSM 从当前状态转移到指定状态。</span></span><br><span class="line"><span class="comment">// 此调用不触发任何回调函数（如果定义）。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">SetState</span><span class="params">(state <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	f.stateMu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.stateMu.Unlock()</span><br><span class="line">	f.current = state</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Can 判断 FSM 在当前状态下，是否可以触发指定事件，如果可以，则返回 true。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">Can</span><span class="params">(event <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	f.eventMu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.eventMu.Unlock()</span><br><span class="line">	f.stateMu.RLock()</span><br><span class="line">	<span class="keyword">defer</span> f.stateMu.RUnlock()</span><br><span class="line">	_, ok := f.transitions[eKey&#123;event, f.current&#125;]</span><br><span class="line">	<span class="keyword">return</span> ok &amp;&amp; (f.transition == <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">Cannot</span><span class="params">(event <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> !f.Can(event)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AvailableTransitions 返回当前状态下可用的转换列表。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">AvailableTransitions</span><span class="params">()</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	f.stateMu.RLock()</span><br><span class="line">	<span class="keyword">defer</span> f.stateMu.RUnlock()</span><br><span class="line">	<span class="keyword">var</span> transitions []<span class="keyword">string</span></span><br><span class="line">	<span class="keyword">for</span> key := <span class="keyword">range</span> f.transitions &#123;</span><br><span class="line">		<span class="keyword">if</span> key.src == f.current &#123;</span><br><span class="line">			transitions = <span class="built_in">append</span>(transitions, key.event)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> transitions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h5><p>与状态转换相关的方法可以说是 <code>FSM</code> 最重要的方法了。</p>
<p>我们先来看 <code>Event</code> 方法的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Event 通过指定事件名称触发状态转换</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">Event</span><span class="params">(ctx context.Context, event <span class="keyword">string</span>, args ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	f.eventMu.Lock() <span class="comment">// 事件互斥锁锁定</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 为了始终解锁事件互斥锁（eventMu），此处添加了 defer 防止状态转换完成后执行 enter/after 回调时仍持有锁；</span></span><br><span class="line">	<span class="comment">// 因为这些回调可能触发新的状态转换，故在下方代码中需要显式解锁</span></span><br><span class="line">	<span class="keyword">var</span> unlocked <span class="keyword">bool</span> <span class="comment">// 标记是否已经解锁</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> !unlocked &#123; <span class="comment">// 如果下方的逻辑已经显式操作过解锁，defer 中无需重复解锁</span></span><br><span class="line">			f.eventMu.Unlock()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	f.stateMu.RLock() <span class="comment">// 获取状态读锁</span></span><br><span class="line">	<span class="keyword">defer</span> f.stateMu.RUnlock()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> 之前的转换尚未完成</span></span><br><span class="line">	<span class="keyword">if</span> f.transition != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">// 上一次状态转换还未完成，返回"前一个转换未完成"错误</span></span><br><span class="line">		<span class="keyword">return</span> InTransitionError&#123;event&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> 事件 event 在当前状态 current 下是否适用，即是否在 transitions 表中</span></span><br><span class="line">	dst, ok := f.transitions[eKey&#123;event, f.current&#125;]</span><br><span class="line">	<span class="keyword">if</span> !ok &#123; <span class="comment">// 无效事件</span></span><br><span class="line">		<span class="keyword">for</span> ekey := <span class="keyword">range</span> f.transitions &#123;</span><br><span class="line">			<span class="keyword">if</span> ekey.event == event &#123;</span><br><span class="line">				<span class="comment">// 事件和当前状态不对应</span></span><br><span class="line">				<span class="keyword">return</span> InvalidEventError&#123;event, f.current&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 未定义的事件</span></span><br><span class="line">		<span class="keyword">return</span> UnknownEventError&#123;event&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line">	<span class="comment">// 构造一个事件对象</span></span><br><span class="line">	e := &amp;Event&#123;f, event, f.current, dst, <span class="literal">nil</span>, args, <span class="literal">false</span>, <span class="literal">false</span>, cancel&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> 执行 before 钩子</span></span><br><span class="line">	err := f.beforeEventCallbacks(ctx, e)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> 当前状态等于目标状态，无需转换</span></span><br><span class="line">	<span class="keyword">if</span> f.current == dst &#123;</span><br><span class="line">		f.stateMu.RUnlock()</span><br><span class="line">		<span class="keyword">defer</span> f.stateMu.RLock()</span><br><span class="line">		f.eventMu.Unlock()</span><br><span class="line">		unlocked = <span class="literal">true</span></span><br><span class="line">		<span class="comment">// <span class="doctag">NOTE:</span> 执行 after 钩子</span></span><br><span class="line">		f.afterEventCallbacks(ctx, e)</span><br><span class="line">		<span class="keyword">return</span> NoTransitionError&#123;e.Err&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义状态转换闭包函数</span></span><br><span class="line">	transitionFunc := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, async <span class="keyword">bool</span>)</span> <span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">if</span> ctx.Err() != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> e.Err == <span class="literal">nil</span> &#123;</span><br><span class="line">					e.Err = ctx.Err()</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			f.stateMu.Lock()</span><br><span class="line">			f.current = dst    <span class="comment">// 状态转换</span></span><br><span class="line">			f.transition = <span class="literal">nil</span> <span class="comment">// <span class="doctag">NOTE:</span> 标记状态转换完成</span></span><br><span class="line">			f.stateMu.Unlock()</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 显式解锁 eventMu 事件互斥锁，允许 enterStateCallbacks 回调函数触发新的状态转换操作（避免死锁）</span></span><br><span class="line">			<span class="comment">// 对于异步状态转换，无需显式解锁，锁已在触发异步操作时释放</span></span><br><span class="line">			<span class="keyword">if</span> !async &#123;</span><br><span class="line">				f.eventMu.Unlock()</span><br><span class="line">				unlocked = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// <span class="doctag">NOTE:</span> 执行 enter 钩子</span></span><br><span class="line">			f.enterStateCallbacks(ctx, e)</span><br><span class="line">			<span class="comment">// <span class="doctag">NOTE:</span> 执行 after 钩子</span></span><br><span class="line">			f.afterEventCallbacks(ctx, e)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 记录状态转换函数（这里标记为同步转换）</span></span><br><span class="line">	f.transition = transitionFunc(ctx, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> 执行 leave 钩子</span></span><br><span class="line">	<span class="keyword">if</span> err = f.leaveStateCallbacks(ctx, e); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> _, ok := err.(CanceledError); ok &#123;</span><br><span class="line">			f.transition = <span class="literal">nil</span> <span class="comment">// <span class="doctag">NOTE:</span> 如果通过 ctx 取消了，则标记为 nil，无需转换</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> asyncError, ok := err.(AsyncError); ok &#123; <span class="comment">// <span class="doctag">NOTE:</span> 如果是 AsyncError，说明是异步转换</span></span><br><span class="line">			<span class="comment">// 为异步操作创建独立上下文，以便异步状态转换正常工作</span></span><br><span class="line">			<span class="comment">// 这个新的 ctx 实际上已经脱离了原始 ctx，原 ctx 取消不会影响当前 ctx</span></span><br><span class="line">			<span class="comment">// 不过新的 ctx 保留了原始 ctx 的值，所有通过 ctx 传递的值还可以继续使用</span></span><br><span class="line">			ctx, cancel := uncancelContext(ctx)</span><br><span class="line">			e.cancelFunc = cancel                    <span class="comment">// 绑定新取消函数</span></span><br><span class="line">			asyncError.Ctx = ctx                     <span class="comment">// 传递新上下文</span></span><br><span class="line">			asyncError.CancelTransition = cancel     <span class="comment">// 暴露取消接口</span></span><br><span class="line">			f.transition = transitionFunc(ctx, <span class="literal">true</span>) <span class="comment">// <span class="doctag">NOTE:</span> 标记为异步转换状态</span></span><br><span class="line">			<span class="comment">// <span class="doctag">NOTE:</span> 如果是异步转换，直接返回，不会同步调用 f.doTransition()，需要用户手动调用 f.Transition() 来触发状态转换</span></span><br><span class="line">			<span class="keyword">return</span> asyncError</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Perform the rest of the transition, if not asynchronous.</span></span><br><span class="line">	f.stateMu.RUnlock()</span><br><span class="line">	<span class="keyword">defer</span> f.stateMu.RLock()</span><br><span class="line">	err = f.doTransition() <span class="comment">// <span class="doctag">NOTE:</span> 执行状态转换逻辑，即调用 f.transition()</span></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> InternalError&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> e.Err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>Event</code> 是核心方法，所以源码会比较多，我们一起来梳理下核心逻辑。</p>
<p>首先，<code>Event</code> 方法会判断上一次的状态转换是否完成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> 之前的转换尚未完成</span></span><br><span class="line"><span class="keyword">if</span> f.transition != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="comment">// 上一次状态转换还未完成，返回"前一个转换未完成"错误</span></span><br><span class="line">	<span class="keyword">return</span> InTransitionError&#123;event&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是否转换完成的标志是 <code>f.transition</code> 是否为 <code>nil</code>，如果上一次状态转换尚未完成，则返回一个 Sentinel Error。</p>
<p>接着，需要判断当前触发的事件是否有效：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> 事件 event 在当前状态 current 下是否适用，即是否在 transitions 表中</span></span><br><span class="line">dst, ok := f.transitions[eKey&#123;event, f.current&#125;]</span><br><span class="line"><span class="keyword">if</span> !ok &#123; <span class="comment">// 无效事件</span></span><br><span class="line">	<span class="keyword">for</span> ekey := <span class="keyword">range</span> f.transitions &#123;</span><br><span class="line">		<span class="keyword">if</span> ekey.event == event &#123;</span><br><span class="line">			<span class="comment">// 事件和当前状态不对应</span></span><br><span class="line">			<span class="keyword">return</span> InvalidEventError&#123;event, f.current&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 未定义的事件</span></span><br><span class="line">	<span class="keyword">return</span> UnknownEventError&#123;event&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前文中我们说过 <code>f.transitions</code> 用于记录状态转换规则，即定义触发某一事件时，允许从某一种状态，转换成另一种状态。</p>
<p>如果在 <code>f.transitions</code> 表中查不到任何一条与当前状态和事件对应的数据，则表示无效事件，同样会返回指定的 Sentinel Error。</p>
<p>这些检查都通过后，就会构造一个事件对象：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctx, cancel := context.WithCancel(ctx)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"><span class="comment">// 构造一个事件对象</span></span><br><span class="line">e := &amp;Event&#123;f, event, f.current, dst, <span class="literal">nil</span>, args, <span class="literal">false</span>, <span class="literal">false</span>, cancel&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，就到了状态转换的核心逻辑了。而所有的回调函数，也是在这个时候开始触发执行的。</p>
<p>在执行状态转换之前，首先要执行的就是 <code>before</code> 类回调函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> 执行 before 钩子</span></span><br><span class="line">err := f.beforeEventCallbacks(ctx, e)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行完 <code>before</code> 类回调函数，会再对状态做一次检查：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> 当前状态等于目标状态，无需转换</span></span><br><span class="line"><span class="keyword">if</span> f.current == dst &#123;</span><br><span class="line">	f.stateMu.RUnlock()</span><br><span class="line">	<span class="keyword">defer</span> f.stateMu.RLock()</span><br><span class="line">	f.eventMu.Unlock()</span><br><span class="line">	unlocked = <span class="literal">true</span></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> 执行 after 钩子</span></span><br><span class="line">	f.afterEventCallbacks(ctx, e)</span><br><span class="line">	<span class="keyword">return</span> NoTransitionError&#123;e.Err&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果状态机的当前状态等于目标状态，则无需状态转换，那么直接执行 <code>after</code> 类回调函数就行了，最终返回指定的 Sentinel Error。</p>
<p>否则，需要进行状态转换。此时，状态转换也不会直接进行，而是会定义一个状态转换闭包函数并赋值给 <code>f.transition</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义状态转换闭包函数</span></span><br><span class="line">transitionFunc := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, async <span class="keyword">bool</span>)</span> <span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录状态转换函数（这里标记为同步转换）</span></span><br><span class="line">f.transition = transitionFunc(ctx, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>状态转换函数第二个参数用来标记同步转换还是异步转换，这里标记为同步转换。对于异步转换逻辑，我们后面再来讲解。</p>
<p>接下来会先执行 <code>leave</code> 类的回调函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> 执行 leave 钩子</span></span><br><span class="line"><span class="keyword">if</span> err = f.leaveStateCallbacks(ctx, e); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是调用的第二个回调函数。</p>
<p>最后，终于到了执行状态转换的逻辑了：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">err = f.doTransition() <span class="comment">// <span class="doctag">NOTE:</span> 执行状态转换逻辑，即调用 f.transition()</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> InternalError&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里调用了 <code>f.doTransition()</code> 函数，其定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// doTransition wraps transitioner.transition.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">doTransition</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> f.transitionerObj.transition(f)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，其内部正式调用了 <code>f.transitionerObj</code> 属性的 <code>transition</code> 方法。</p>
<p>还记得 <code>f.transitionerObj</code> 属性是何时赋值吗？在 <code>NewFSM</code> 构造函数中，其赋值如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造有限状态机 FSM</span></span><br><span class="line">f := &amp;FSM&#123;</span><br><span class="line">    transitionerObj: &amp;transitionerStruct&#123;&#125;,        <span class="comment">// 状态转换器，使用默认实现</span></span><br><span class="line">    current:         initial,                      <span class="comment">// 当前状态</span></span><br><span class="line">    transitions:     <span class="built_in">make</span>(<span class="keyword">map</span>[eKey]<span class="keyword">string</span>),        <span class="comment">// 存储「事件和原状态」到「目标状态」的转换规则映射</span></span><br><span class="line">    callbacks:       <span class="built_in">make</span>(<span class="keyword">map</span>[cKey]Callback),      <span class="comment">// 回调函数映射表</span></span><br><span class="line">    metadata:        <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;), <span class="comment">// 元信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们需要看一下 <code>transitionerStruct</code> 的具体实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// transitioner 是 FSM 的状态转换函数接口。</span></span><br><span class="line"><span class="keyword">type</span> transitioner <span class="keyword">interface</span> &#123;</span><br><span class="line">	transition(*FSM) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 状态转换接口的默认实现</span></span><br><span class="line"><span class="keyword">type</span> transitionerStruct <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Transition completes an asynchronous state change.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The callback for leave_&lt;STATE&gt; must previously have called Async on its</span></span><br><span class="line"><span class="comment">// event to have initiated an asynchronous state transition.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t transitionerStruct)</span> <span class="title">transition</span><span class="params">(f *FSM)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> f.transition == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> NotInTransitionError&#123;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	f.transition()</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>f.transitionerObj</code> 属性声明的是 <code>transitioner</code> 接口类型，而 <code>transitionerStruct</code> 结构体则是这个接口的默认实现。</p>
<p><code>transitionerStruct.transition</code> 方法内部最终还是在调用 <code>f.transition()</code> 方法。</p>
<p>而 <code>f.transition</code> 方法，也就是前文中定义的那个闭包函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义状态转换闭包函数</span></span><br><span class="line">transitionFunc := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, async <span class="keyword">bool</span>)</span> <span class="title">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ctx.Err() != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> e.Err == <span class="literal">nil</span> &#123;</span><br><span class="line">                e.Err = ctx.Err()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        f.stateMu.Lock()</span><br><span class="line">        f.current = dst    <span class="comment">// 状态转换</span></span><br><span class="line">        f.transition = <span class="literal">nil</span> <span class="comment">// <span class="doctag">NOTE:</span> 标记状态转换完成</span></span><br><span class="line">        f.stateMu.Unlock()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显式解锁 eventMu 事件互斥锁，允许 enterStateCallbacks 回调函数触发新的状态转换操作（避免死锁）</span></span><br><span class="line">        <span class="comment">// 对于异步状态转换，无需显式解锁，锁已在触发异步操作时释放</span></span><br><span class="line">        <span class="keyword">if</span> !async &#123;</span><br><span class="line">            f.eventMu.Unlock()</span><br><span class="line">            unlocked = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> 执行 enter 钩子</span></span><br><span class="line">        f.enterStateCallbacks(ctx, e)</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> 执行 after 钩子</span></span><br><span class="line">        f.afterEventCallbacks(ctx, e)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录状态转换函数（这里标记为同步转换）</span></span><br><span class="line">f.transition = transitionFunc(ctx, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>闭包函数的 <code>async</code> 参数用来标记同步或异步，我们暂且不关心异步，这里只关注同步逻辑。</p>
<p>其实，这里的核心逻辑就是完成状态转换：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.current = dst    <span class="comment">// 状态转换</span></span><br><span class="line">f.transition = <span class="literal">nil</span> <span class="comment">// <span class="doctag">NOTE:</span> 标记状态转换完成</span></span><br></pre></td></tr></table></figure>

<p>状态转换完成后，将 <code>f.transition</code> 标记为 <code>nil</code>。所以根据这个属性的值，就能判断上一次状态转换是否完成。</p>
<p>状态转换完成后，依次执行 <code>enter</code> 和 <code>after</code> 类回调函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> 执行 enter 钩子</span></span><br><span class="line">f.enterStateCallbacks(ctx, e)</span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> 执行 after 钩子</span></span><br><span class="line">f.afterEventCallbacks(ctx, e)</span><br></pre></td></tr></table></figure>

<p>根据 <code>Event</code> 方法的源码走读，我们可以总结出状态转换的核心流程如下：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="fsm-event2.jpg" alt="FSM Event" title="">
                </div>
                <div class="image-caption">FSM Event</div>
            </figure>

<p>本小节最后再贴一下 <code>Transition</code> 方法的源码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Transition wraps transitioner.transition.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">Transition</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	f.eventMu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.eventMu.Unlock()</span><br><span class="line">	<span class="keyword">return</span> f.doTransition()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><p>现在，我们来看一下回调函数的具体实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// beforeEventCallbacks calls the before_ callbacks, first the named then the</span></span><br><span class="line"><span class="comment">// general version.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">beforeEventCallbacks</span><span class="params">(ctx context.Context, e *Event)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> fn, ok := f.callbacks[cKey&#123;e.Event, callbackBeforeEvent&#125;]; ok &#123;</span><br><span class="line">		fn(ctx, e)</span><br><span class="line">		<span class="keyword">if</span> e.canceled &#123;</span><br><span class="line">			<span class="keyword">return</span> CanceledError&#123;e.Err&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> fn, ok := f.callbacks[cKey&#123;<span class="string">""</span>, callbackBeforeEvent&#125;]; ok &#123;</span><br><span class="line">		fn(ctx, e)</span><br><span class="line">		<span class="keyword">if</span> e.canceled &#123;</span><br><span class="line">			<span class="keyword">return</span> CanceledError&#123;e.Err&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// leaveStateCallbacks calls the leave_ callbacks, first the named then the</span></span><br><span class="line"><span class="comment">// general version.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">leaveStateCallbacks</span><span class="params">(ctx context.Context, e *Event)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> fn, ok := f.callbacks[cKey&#123;f.current, callbackLeaveState&#125;]; ok &#123;</span><br><span class="line">		fn(ctx, e)</span><br><span class="line">		<span class="keyword">if</span> e.canceled &#123;</span><br><span class="line">			<span class="keyword">return</span> CanceledError&#123;e.Err&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> e.async &#123; <span class="comment">// <span class="doctag">NOTE:</span> 异步信号</span></span><br><span class="line">			<span class="keyword">return</span> AsyncError&#123;Err: e.Err&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> fn, ok := f.callbacks[cKey&#123;<span class="string">""</span>, callbackLeaveState&#125;]; ok &#123;</span><br><span class="line">		fn(ctx, e)</span><br><span class="line">		<span class="keyword">if</span> e.canceled &#123;</span><br><span class="line">			<span class="keyword">return</span> CanceledError&#123;e.Err&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> e.async &#123;</span><br><span class="line">			<span class="keyword">return</span> AsyncError&#123;Err: e.Err&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enterStateCallbacks calls the enter_ callbacks, first the named then the</span></span><br><span class="line"><span class="comment">// general version.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">enterStateCallbacks</span><span class="params">(ctx context.Context, e *Event)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> fn, ok := f.callbacks[cKey&#123;f.current, callbackEnterState&#125;]; ok &#123;</span><br><span class="line">		fn(ctx, e)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> fn, ok := f.callbacks[cKey&#123;<span class="string">""</span>, callbackEnterState&#125;]; ok &#123;</span><br><span class="line">		fn(ctx, e)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// afterEventCallbacks calls the after_ callbacks, first the named then the</span></span><br><span class="line"><span class="comment">// general version.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">afterEventCallbacks</span><span class="params">(ctx context.Context, e *Event)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> fn, ok := f.callbacks[cKey&#123;e.Event, callbackAfterEvent&#125;]; ok &#123;</span><br><span class="line">		fn(ctx, e)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> fn, ok := f.callbacks[cKey&#123;<span class="string">""</span>, callbackAfterEvent&#125;]; ok &#123;</span><br><span class="line">		fn(ctx, e)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细心观察，你会发现这几个回调函数逻辑其实套路一样，都是先匹配 <code>cKey</code> 的 <code>target</code> 值为 <code>e.Event</code> 回调函数来执行，然后再匹配 <code>target</code> 值为 <code>&quot;&quot;</code> 的回调函数来执行。</p>
<p>还记得 <code>target</code> 何时才会为空吗？我们一起回顾下 <code>NewFSM</code> 中的代码段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据回调函数名称前缀分类</span></span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="comment">// 事件触发前执行</span></span><br><span class="line"><span class="keyword">case</span> strings.HasPrefix(name, <span class="string">"before_"</span>):</span><br><span class="line">    target = strings.TrimPrefix(name, <span class="string">"before_"</span>)</span><br><span class="line">    <span class="keyword">if</span> target == <span class="string">"event"</span> &#123; <span class="comment">// 全局事件前置钩子（任何事件触发都会调用，如用于日志记录场景）</span></span><br><span class="line">        target = <span class="string">""</span> <span class="comment">// 将 target 置空</span></span><br><span class="line">        callbackType = callbackBeforeEvent</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> _, ok := allEvents[target]; ok &#123; <span class="comment">// 在特定事件前执行</span></span><br><span class="line">        callbackType = callbackBeforeEvent</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 离开当前状态前执行</span></span><br><span class="line"><span class="keyword">case</span> strings.HasPrefix(name, <span class="string">"leave_"</span>):</span><br><span class="line">    target = strings.TrimPrefix(name, <span class="string">"leave_"</span>)</span><br><span class="line">    <span class="keyword">if</span> target == <span class="string">"state"</span> &#123; <span class="comment">// 全局状态离开钩子</span></span><br><span class="line">        target = <span class="string">""</span></span><br><span class="line">        callbackType = callbackLeaveState</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> _, ok := allStates[target]; ok &#123; <span class="comment">// 离开旧状态前执行</span></span><br><span class="line">        callbackType = callbackLeaveState</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>target</code> 的值为 <code>event/state</code> 是，就会标记为 <code>&quot;&quot;</code>。</p>
<p>所以，我们可以得出结论：<code>xxx_event</code> 或 <code>xxx_state</code> 回调函数，会晚于 <code>xxx_&lt;EVENT&gt;</code> 或 <code>xxx_&lt;STATE&gt;</code> 而执行。</p>
<p>那么，至此我们就理清了状态转换时所有的回调函数执行顺序：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="fsm-event3.jpg" alt="FSM Event" title="">
                </div>
                <div class="image-caption">FSM Event</div>
            </figure>

<p>而这一结论，与我们在上一篇文章中讲解的示例程序执行输出结果保持一致：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="fsm-event4.jpg" alt="FSM Event" title="">
                </div>
                <div class="image-caption">FSM Event</div>
            </figure>

<p>此外，不知道你有没有发现，其实我在上一篇文章中挖了一个坑没有详细讲解。</p>
<p>在前一篇文章中，我们定义了如下状态转换规则：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fsm.Events&#123;</span><br><span class="line">    &#123;Name: <span class="string">"open"</span>, Src: []<span class="keyword">string</span>&#123;<span class="string">"closed"</span>&#125;, Dst: <span class="string">"open"</span>&#125;,</span><br><span class="line">    &#123;Name: <span class="string">"close"</span>, Src: []<span class="keyword">string</span>&#123;<span class="string">"open"</span>&#125;, Dst: <span class="string">"closed"</span>&#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>细心的你可能已经发现，其实第一条规则中，事件和目标状态，都叫 <code>open</code>；而第二条规则中，事件叫 <code>close</code>，目标状态叫 <code>closed</code>。</p>
<p>那么你有没有思考过，当事件和目标状态同名时，即在这里 <code>open</code> 既是 <code>event</code> 又是 <code>state</code>，那么定义如下回调函数，这个回调函数是属于 <code>event</code> 还是 <code>state</code> 呢？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"open"</span>: <span class="function"><span class="keyword">func</span><span class="params">(_ context.Context, e *fsm.Event)</span></span> &#123;</span><br><span class="line">    color.Green(<span class="string">"| enter open\t | %s | %s |"</span>, e.Src, e.Dst)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>我们知道，<code>&lt;NEW_STATE&gt;</code> 是 <code>enter_&lt;NEW_STATE&gt;</code> 的简写形式，而 <code>&lt;EVENT&gt;</code> 又是 <code>after_&lt;EVENT&gt;</code> 的简写形式。</p>
<p>我们还知道，这段逻辑是在 <code>NewFSM</code> 中的 <code>default</code> case 代码中实现的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理未加前缀的回调（简短版本）</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    target = name                       <span class="comment">// 状态/事件</span></span><br><span class="line">    <span class="keyword">if</span> _, ok := allStates[target]; ok &#123; <span class="comment">// 如果 target 为某个状态，则 callbackType 会置为与 enter_[target] 相同</span></span><br><span class="line">        callbackType = callbackEnterState</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> _, ok := allEvents[target]; ok &#123; <span class="comment">// 如果 target 为某个事件，则 callbackType 会置为与 after_[target] 相同</span></span><br><span class="line">        callbackType = callbackAfterEvent</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>而这段代码中，优先使用 <code>allStates[target]</code> 来匹配 <code>target</code>，即 <code>open</code> 会优先当作 <code>state</code> 来处理。</p>
<p>至此，关于回调函数的全部逻辑才算梳理完成。</p>
<h5 id="元信息"><a href="#元信息" class="headerlink" title="元信息"></a>元信息</h5><p><code>FSM</code> 对于元信息的操作非常简单，所有涉及元信息操作的方法源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Metadata 返回存储在元信息中的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">Metadata</span><span class="params">(key <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">interface</span>&#123;&#125;, <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">	f.metadataMu.RLock()</span><br><span class="line">	<span class="keyword">defer</span> f.metadataMu.RUnlock()</span><br><span class="line">	dataElement, ok := f.metadata[key]</span><br><span class="line">	<span class="keyword">return</span> dataElement, ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SetMetadata 存储 key、val 到元信息中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">SetMetadata</span><span class="params">(key <span class="keyword">string</span>, dataValue <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	f.metadataMu.Lock()</span><br><span class="line">	<span class="keyword">defer</span> f.metadataMu.Unlock()</span><br><span class="line">	f.metadata[key] = dataValue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeleteMetadata 从元信息中删除指定 key 对应的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">DeleteMetadata</span><span class="params">(key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	f.metadataMu.Lock()</span><br><span class="line">	<span class="built_in">delete</span>(f.metadata, key)</span><br><span class="line">	f.metadataMu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于元信息有什么用，我将用一个示例进行讲解。</p>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>对于 <code>FSM</code> 的元信息和异步状态转换操作，仅通过阅读源码，可能无法体会其使用场景。本小节将分别使用两个示例对其进行演示，以此来加深你的理解。</p>
<h4 id="元信息使用"><a href="#元信息使用" class="headerlink" title="元信息使用"></a>元信息使用</h4><p>对于有限状态机中元信息的使用，我写了一个使用示例：</p>
<blockquote>
<p><a href="https://github.com/jianghushinian/blog-go-example/blob/main/fsm/examples/data/data.go" target="_blank" rel="noopener">https://github.com/jianghushinian/blog-go-example/blob/main/fsm/examples/data/data.go</a></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/looplab/fsm"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> 将 FSM 作为生产者消费者使用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fsm := fsm.NewFSM(</span><br><span class="line">		<span class="string">"idle"</span>,</span><br><span class="line">		fsm.Events&#123;</span><br><span class="line">			<span class="comment">// 生产者</span></span><br><span class="line">			&#123;Name: <span class="string">"produce"</span>, Src: []<span class="keyword">string</span>&#123;<span class="string">"idle"</span>&#125;, Dst: <span class="string">"idle"</span>&#125;,</span><br><span class="line">			<span class="comment">// 消费者</span></span><br><span class="line">			&#123;Name: <span class="string">"consume"</span>, Src: []<span class="keyword">string</span>&#123;<span class="string">"idle"</span>&#125;, Dst: <span class="string">"idle"</span>&#125;,</span><br><span class="line">			<span class="comment">// 清理数据</span></span><br><span class="line">			&#123;Name: <span class="string">"remove"</span>, Src: []<span class="keyword">string</span>&#123;<span class="string">"idle"</span>&#125;, Dst: <span class="string">"idle"</span>&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		fsm.Callbacks&#123;</span><br><span class="line">			<span class="comment">// 生产者</span></span><br><span class="line">			<span class="string">"produce"</span>: <span class="function"><span class="keyword">func</span><span class="params">(_ context.Context, e *fsm.Event)</span></span> &#123;</span><br><span class="line">				dataValue := <span class="string">"江湖十年"</span></span><br><span class="line">				e.FSM.SetMetadata(<span class="string">"message"</span>, dataValue)</span><br><span class="line">				fmt.Printf(<span class="string">"produced data: %s\n"</span>, dataValue)</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="comment">// 消费者</span></span><br><span class="line">			<span class="string">"consume"</span>: <span class="function"><span class="keyword">func</span><span class="params">(_ context.Context, e *fsm.Event)</span></span> &#123;</span><br><span class="line">				data, ok := e.FSM.Metadata(<span class="string">"message"</span>)</span><br><span class="line">				<span class="keyword">if</span> ok &#123;</span><br><span class="line">					fmt.Printf(<span class="string">"consume data: %s\n"</span>, data)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="comment">// 清理数据</span></span><br><span class="line">			<span class="string">"remove"</span>: <span class="function"><span class="keyword">func</span><span class="params">(_ context.Context, e *fsm.Event)</span></span> &#123;</span><br><span class="line">				e.FSM.DeleteMetadata(<span class="string">"message"</span>)</span><br><span class="line">				<span class="keyword">if</span> _, ok := e.FSM.Metadata(<span class="string">"message"</span>); !ok &#123;</span><br><span class="line">					fmt.Println(<span class="string">"removed data"</span>)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"current state: %s\n"</span>, fsm.Current())</span><br><span class="line"></span><br><span class="line">	err := fsm.Event(context.Background(), <span class="string">"produce"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"produce err: %s\n"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"current state: %s\n"</span>, fsm.Current())</span><br><span class="line"></span><br><span class="line">	err = fsm.Event(context.Background(), <span class="string">"consume"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"consume err: %s\n"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"current state: %s\n"</span>, fsm.Current())</span><br><span class="line"></span><br><span class="line">	err = fsm.Event(context.Background(), <span class="string">"remove"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">"remove err: %s\n"</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">"current state: %s\n"</span>, fsm.Current())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，将 <code>FSM</code> 作为了生产者消费者来使用。而数据的传递，正是通过元信息（<code>FSM.metadata</code>）来实现的。 </p>
<ul>
<li><code>FSM.SetMetadata</code> 用于设置元信息。</li>
<li><code>FSM.Metadata</code> 用于获取元信息。</li>
<li><code>FSM.DeleteMetadata</code> 则用于清理元信息。</li>
</ul>
<p>执行示例代码，得到输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ go run examples/data/data.go</span><br><span class="line">current state: idle</span><br><span class="line">produced data: 江湖十年</span><br><span class="line">produce err: no transition</span><br><span class="line">current state: idle</span><br><span class="line">consume data: 江湖十年</span><br><span class="line">consume err: no transition</span><br><span class="line">current state: idle</span><br><span class="line">removed data</span><br><span class="line">remove err: no transition</span><br><span class="line">current state: idle</span><br></pre></td></tr></table></figure>

<p>可以发现，在数据的传递过程中，我们得到了 <code>no transition</code> 错误，而这个错误其实我们之前有解读过，是在 <code>Event</code> 方法如下代码段中产生的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> 当前状态等于目标状态，无需转换</span></span><br><span class="line"><span class="keyword">if</span> f.current == dst &#123;</span><br><span class="line">    f.stateMu.RUnlock()</span><br><span class="line">    <span class="keyword">defer</span> f.stateMu.RLock()</span><br><span class="line">    f.eventMu.Unlock()</span><br><span class="line">    unlocked = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 执行 after 钩子</span></span><br><span class="line">    f.afterEventCallbacks(ctx, e)</span><br><span class="line">    <span class="keyword">return</span> NoTransitionError&#123;e.Err&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>FSM</code> 的状态始终是 <code>idle</code>，尚未发生状态转换，所以会返回 <code>NoTransitionError</code> 这个 Sentinel Error。</p>
<p>所以，我们只需要忽略这个 <code>NoTransitionError</code>，那么就能把状态机 <code>FSM</code> 当作生产者消费者来使用。</p>
<p>当然要实现生产者消费者功能我们有很多其他的选择，这个示例主要是作为演示，让我们能够清晰的知道 <code>FSM</code> 提供的元信息功能如何使用。</p>
<h4 id="异步示例"><a href="#异步示例" class="headerlink" title="异步示例"></a>异步示例</h4><p>在 <code>FSM</code> 源码解读的过程中，我有意避而不谈异步状态转换。是因为没有示例的讲解，直接阅读源码，不太容易理解。</p>
<p>我在这里为你演示一个示例，让你来体会一下异步状态转换的用法：</p>
<blockquote>
<p><a href="https://github.com/jianghushinian/blog-go-example/blob/main/fsm/examples/async/async_transition.go" target="_blank" rel="noopener">https://github.com/jianghushinian/blog-go-example/blob/main/fsm/examples/async/async_transition.go</a></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"context"</span></span><br><span class="line">	<span class="string">"errors"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line">	<span class="string">"github.com/looplab/fsm"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> 异步状态转换</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 构造有限状态机</span></span><br><span class="line">	f := fsm.NewFSM(</span><br><span class="line">		<span class="string">"start"</span>,</span><br><span class="line">		fsm.Events&#123;</span><br><span class="line">			&#123;Name: <span class="string">"run"</span>, Src: []<span class="keyword">string</span>&#123;<span class="string">"start"</span>&#125;, Dst: <span class="string">"end"</span>&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		fsm.Callbacks&#123;</span><br><span class="line">			<span class="comment">// 注册 leave_&lt;OLD_STATE&gt; 回调函数</span></span><br><span class="line">			<span class="string">"leave_start"</span>: <span class="function"><span class="keyword">func</span><span class="params">(_ context.Context, e *fsm.Event)</span></span> &#123;</span><br><span class="line">				e.Async() <span class="comment">// <span class="doctag">NOTE:</span> 标记为异步，触发事件时不进行状态转换</span></span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> 触发 run 事件，但不会完整状态转换</span></span><br><span class="line">	err := f.Event(context.Background(), <span class="string">"run"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> Sentinel Error `fsm.AsyncError` 标识异步状态转换</span></span><br><span class="line">	<span class="keyword">var</span> asyncError fsm.AsyncError</span><br><span class="line">	ok := errors.As(err, &amp;asyncError)</span><br><span class="line">	<span class="keyword">if</span> !ok &#123;</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"expected error to be 'AsyncError', got %v"</span>, err))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> 主动执行状态转换操作</span></span><br><span class="line">	<span class="keyword">if</span> err = f.Transition(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"Error encountered when transitioning: %v"</span>, err))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// <span class="doctag">NOTE:</span> 当前状态</span></span><br><span class="line">	fmt.Printf(<span class="string">"current state: %s\n"</span>, f.Current())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例中，在构造有限状态机对象 <code>f</code> 时，为其注册了 <code>leave_start</code> 回调函数，这个回调函数是异步状态转换的关键所在。其内部通过 <code>e.Async()</code> 将事件标记为异步，这样在事件触发时，就不会执行状态转换逻辑。</p>
<p>接着，代码中触发 <code>run</code> 事件。不过由于 <code>e.Async()</code> 的操作，事件触发时不会进行状态转换，而是返回 Sentinel Error <code>fsm.AsyncError</code>，这个错误用于标识这是一个异步操作，尚未进行状态转换。</p>
<p>接下来，我们主动调用 <code>f.Transition()</code> 来执行状态转换操作。</p>
<p>最终，打印 <code>FSM</code> 当前状态。</p>
<p>执行示例代码，得到输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go run examples/async/async_transition.go </span><br><span class="line">current state: end</span><br></pre></td></tr></table></figure>

<p>这个玩法，将触发事件和状态转换操作进行了分离，使得我们可以主动控制状态转换的时机。</p>
<p>这个示例的关键步骤是在 <code>leave_start</code> 回调函数中的 <code>e.Async()</code> 逻辑，将当前事件标记为了异步。</p>
<p>首先，<code>Event</code> 对象其实也是一个结构体，它有一个属性 <code>async</code>，<code>e.Async()</code> 逻辑如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Event)</span> <span class="title">Async</span><span class="params">()</span></span> &#123;</span><br><span class="line">	e.async = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而 <code>leave_start</code> 回调函数，是在调用 <code>*FSM.Event</code> 方法时触发的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> 执行 leave 钩子</span></span><br><span class="line"><span class="keyword">if</span> err = f.leaveStateCallbacks(ctx, e); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> _, ok := err.(CanceledError); ok &#123;</span><br><span class="line">        f.transition = <span class="literal">nil</span> <span class="comment">// <span class="doctag">NOTE:</span> 如果通过 ctx 取消了，则标记为 nil，无需转换</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> asyncError, ok := err.(AsyncError); ok &#123; <span class="comment">// <span class="doctag">NOTE:</span> 如果是 AsyncError，说明是异步转换</span></span><br><span class="line">        <span class="comment">// 为异步操作创建独立上下文，以便异步状态转换正常工作</span></span><br><span class="line">        <span class="comment">// 这个新的 ctx 实际上已经脱离了原始 ctx，原 ctx 取消不会影响当前 ctx</span></span><br><span class="line">        <span class="comment">// 不过新的 ctx 保留了原始 ctx 的值，所有通过 ctx 传递的值还可以继续使用</span></span><br><span class="line">        ctx, cancel := uncancelContext(ctx)</span><br><span class="line">        e.cancelFunc = cancel                    <span class="comment">// 绑定新取消函数</span></span><br><span class="line">        asyncError.Ctx = ctx                     <span class="comment">// 传递新上下文</span></span><br><span class="line">        asyncError.CancelTransition = cancel     <span class="comment">// 暴露取消接口</span></span><br><span class="line">        f.transition = transitionFunc(ctx, <span class="literal">true</span>) <span class="comment">// <span class="doctag">NOTE:</span> 标记为异步转换状态</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> 如果是异步转换，直接返回，不会同步调用 f.doTransition()，需要用户手动调用 f.Transition() 来触发状态转换</span></span><br><span class="line">        <span class="keyword">return</span> asyncError</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>f.leaveStateCallbacks</code> 就是在执行 <code>leave_start</code> 回调函数，其实现如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *FSM)</span> <span class="title">leaveStateCallbacks</span><span class="params">(ctx context.Context, e *Event)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> fn, ok := f.callbacks[cKey&#123;f.current, callbackLeaveState&#125;]; ok &#123;</span><br><span class="line">		fn(ctx, e)</span><br><span class="line">		<span class="keyword">if</span> e.canceled &#123;</span><br><span class="line">			<span class="keyword">return</span> CanceledError&#123;e.Err&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> e.async &#123; <span class="comment">// <span class="doctag">NOTE:</span> 异步信号</span></span><br><span class="line">			<span class="keyword">return</span> AsyncError&#123;Err: e.Err&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里最关键的一步就是在 <code>else if e.async</code> 时，返回 Sentinel Error <code>AsyncError</code>。</p>
<p>而对 <code>f.leaveStateCallbacks(ctx, e)</code> 的调用一旦返回 <code>AsyncError</code>，就说明是要进入异步状态转换逻辑。</p>
<p>此时会为 <code>f.transition</code> 重新赋值，并标记为异步状态转换：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f.transition = transitionFunc(ctx, <span class="literal">true</span>) <span class="comment">// <span class="doctag">NOTE:</span> 标记为异步转换状态</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> 如果是异步转换，直接返回，不会同步调用 f.doTransition()，需要用户手动调用 f.Transition() 来触发状态转换</span></span><br><span class="line"><span class="keyword">return</span> asyncError</span><br></pre></td></tr></table></figure>

<p>并且返回 <code>asyncError</code>，这次 <code>Event</code> 事件触发就完成了。不过并没有接着去执行 <code>f.transition()</code> 逻辑。所以就实现了异步操作。</p>
<p>到这里，异步转换状态的逻辑，我就帮你梳理完成了。这块可能不太好理解，但是你跟着我的思路，执行一遍示例代码，然后深入到源码，按照流程再梳理一遍，相信就就一定能理解了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上一篇文章我们一起学习了如何利用有限状态机 <code>FSM</code> 实现程序中的状态转换。</p>
<p>本篇文章我带你完整阅读了有限状态机的核心源码，为你理清了 <code>FSM</code> 的设计思路和它提供的能力。让你能够知其然，也能知其所以然。</p>
<p>并且我还针对不太常用的元信息操作和异步状态转换，提供了使用示例。其实官方 <a href="https://github.com/looplab/fsm/tree/main/examples" target="_blank" rel="noopener">examples</a> 中提供了好几个示例，你可以自行看一下，学完了本文源码，再去看示例就是小菜一碟的事情了。</p>
<p>值得注意的是，因为所有的状态转换核心逻辑都加了互斥锁，所以 <code>FSM</code> 是并发安全的。</p>
<p>本文示例源码我都放在了 <a href="https://github.com/jianghushinian/blog-go-example/tree/main/fsm" target="_blank" rel="noopener">GitHub</a> 中，欢迎点击查看。</p>
<p>希望此文能对你有所启发。</p>
<p><strong>延伸阅读</strong></p>
<ul>
<li>有限状态机定义：<a href="https://zh.wikipedia.org/wiki/有限状态机" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/有限状态机</a></li>
<li>JavaScript与有限状态机：<a href="https://www.ruanyifeng.com/blog/2013/09/finite-state_machine_for_javascript.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2013/09/finite-state_machine_for_javascript.html</a></li>
<li>OneX 有限状态机：<a href="https://github.com/onexstack/onex/tree/feature/onex-v2/internal/nightwatch/watcher/user" target="_blank" rel="noopener">https://github.com/onexstack/onex/tree/feature/onex-v2/internal/nightwatch/watcher/user</a></li>
<li>fsm GitHub 源码：<a href="https://github.com/looplab/fsm" target="_blank" rel="noopener">https://github.com/looplab/fsm</a></li>
<li>fsm Documentation：<a href="https://pkg.go.dev/github.com/looplab/fsm@v1.0.3" target="_blank" rel="noopener">https://pkg.go.dev/github.com/looplab/fsm@v1.0.3</a></li>
<li>在 Go 中如何使用有限状态机优雅解决程序中状态转换问题：<a href="https://jianghushinian.cn/2025/05/25/fsm/" target="_blank" rel="noopener">https://jianghushinian.cn/2025/05/25/fsm/</a></li>
<li>本文 GitHub 示例代码：<a href="https://github.com/jianghushinian/blog-go-example/tree/main/fsm" target="_blank" rel="noopener">https://github.com/jianghushinian/blog-go-example/tree/main/fsm</a></li>
<li>本文永久地址：<a href="https://jianghushinian.cn/2025/06/01/fsm-source-code/" target="_blank" rel="noopener">https://jianghushinian.cn/2025/06/01/fsm-source-code/</a></li>
</ul>
<p><strong>联系我</strong></p>
<ul>
<li>公众号：<a href="https://jianghushinian.cn/about" target="_blank" rel="noopener">Go编程世界</a></li>
<li>微信：jianghushinian</li>
<li>邮箱：<a href="mailto:jianghushinian007@outlook.com">jianghushinian007@outlook.com</a></li>
<li>博客：<a href="https://jianghushinian.cn" target="_blank" rel="noopener">https://jianghushinian.cn</a></li>
<li>GitHub：<a href="https://github.com/jianghushinian" target="_blank" rel="noopener">https://github.com/jianghushinian</a></li>
</ul>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2025-06-01T09:58:40.260Z" itemprop="dateUpdated">2025-06-01 17:58:40</time>
</span><br>


        
        <a href="/2025/06/01/fsm-source-code/" target="_blank" rel="external">http://www.jianghushinian.cn/2025/06/01/fsm-source-code/</a>
        
    </div>
    
    <footer>
        <a href="http://www.jianghushinian.cn">
            <img src="/img/avatar.png" alt="江湖十年">
            江湖十年
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/FSM/" rel="tag">FSM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Go/" rel="tag">Go</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA/" rel="tag">有限状态机</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://www.jianghushinian.cn/2025/06/01/fsm-source-code/&title=《Go 语言 fsm 源码解读，这一次让你彻底学会有限状态机》 — 江湖十年&pic=http://www.jianghushinian.cn/img/avatar.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.jianghushinian.cn/2025/06/01/fsm-source-code/&title=《Go 语言 fsm 源码解读，这一次让你彻底学会有限状态机》 — 江湖十年&source=我在文章《在 Go 中如何使用有限状态机优雅解决程序中状态转换问题》中讲解了有限状态机的概念，并介绍了 Go 中有限状态机 fsm 包的使用。本篇文章，我..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://www.jianghushinian.cn/2025/06/01/fsm-source-code/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Go 语言 fsm 源码解读，这一次让你彻底学会有限状态机》 — 江湖十年&url=http://www.jianghushinian.cn/2025/06/01/fsm-source-code/&via=http://www.jianghushinian.cn" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://www.jianghushinian.cn/2025/06/01/fsm-source-code/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2025/06/08/empty-struct-as-key-of-ctx/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">在 Go 中为什么推荐使用空结构体作为 Context 的 key</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2025/05/25/fsm/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">在 Go 中如何使用有限状态机优雅解决程序中状态转换问题</h4>
      </a>
    </div>
  
</nav>



    


    <script src="/js/md5.min.js"></script>
    <section class="comments" id="comments">
        <div id="disqus_thread"></div>
        <script type="text/javascript">
            var disqus_shortname = 'https-jianghushinian-cn';
            var disqus_identifier = location.pathname.slice(1,);
            var disqus_url = 'https://jianghushinian.cn/' + disqus_identifier;
            (function () {
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the comments.</noscript>
    </section>


















</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        <span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        <span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>江湖十年 &copy; 2019 - 2025</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://www.jianghushinian.cn/2025/06/01/fsm-source-code/&title=《Go 语言 fsm 源码解读，这一次让你彻底学会有限状态机》 — 江湖十年&pic=http://www.jianghushinian.cn/img/avatar.png" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.jianghushinian.cn/2025/06/01/fsm-source-code/&title=《Go 语言 fsm 源码解读，这一次让你彻底学会有限状态机》 — 江湖十年&source=我在文章《在 Go 中如何使用有限状态机优雅解决程序中状态转换问题》中讲解了有限状态机的概念，并介绍了 Go 中有限状态机 fsm 包的使用。本篇文章，我..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://www.jianghushinian.cn/2025/06/01/fsm-source-code/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《Go 语言 fsm 源码解读，这一次让你彻底学会有限状态机》 — 江湖十年&url=http://www.jianghushinian.cn/2025/06/01/fsm-source-code/&via=http://www.jianghushinian.cn" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://www.jianghushinian.cn/2025/06/01/fsm-source-code/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=http://www.jianghushinian.cn/2025/06/01/fsm-source-code/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
